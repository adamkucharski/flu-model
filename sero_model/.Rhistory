# Simulate random infection history for each participant
if(is.null(historytabPost)){
historytabSim=NULL
for(ii in 1:n_part){
hist0=(runif(inf.n)<attack.yr)+0
alive=((max(test_years)-age.yr[ii])<=inf_years)
historytabSim=rbind(historytabSim,hist0*alive)
}
}else{
historytabSim=historytabPost
}
# Simulate titres for each participant
# ** NEED TO INCLUDE TEST YEAR IN FUNCTION IF DECAY ADDED **
test.list=list()
for(ii in 1:n_part){
subjectn=ii
i.list=list()
historyii=historytabSim[ii,]
for(jj in 1:test.n){
d.ij=dmatrix[sample.index,] # Define cross-immunity matrix for sample strain
d_vector=melt(t(d.ij))$value
testyr=test_years[jj]
testyearI=c(1:inf.n)[inf_years==testyr]
expect=func1(historyii,sample.index,d_vector,thetastar,testyearI) # Output expectation
#titredat=sapply(expect,function(x){rpois(1,x)}) # Generate titre
titredat=round(expect)
titredat=sapply(titredat,function(x){min(x,8)})
i.list[[jj]]=rbind(test.year=rep(testyr,nstrains),
titredat,
strain_years,
sample.index
)
}
#i.list[[1]][2,]
#
test.list[[ii]]=i.list
}
# Export data
#browser()
if(is.null(historytabPost)){
save(test_years,inf_years,strain_years,n_part,test.list,age.yr,historytabSim,file=paste("R_datasets/Simulated_data.RData",sep=""))
}else{
save(test_years,inf_years,strain_years,n_part,test.list,age.yr,file=paste("R_datasets/Simulated_dataPost.RData",sep=""))
}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Resample infection history - included ageA table in case needed later
SampleHistory<-function(historyA,pick,inf.n,ageA,inf_years){
infvector=c(1:inf.n)
infvector2=rev(infvector)
for(ii in pick){
#ls_pick=foreach(ii=(1:length(pick))) %dopar% {  # Parallel loop - slower to farm out
rand1=runif(1)
x=historyA[ii,]
# Remove infection
if(rand1<1/3){
infectID=infvector[(as.numeric(x)>0)]
if(length(infectID)>0){
x[sample(c(infectID,infectID),1)]=0
}
}
# Add new infection
if(rand1>1/3 & rand1<2/3){
ninfecID=infvector[(as.numeric(x)==0)]
if(length(ninfecID)>0){
x[sample(c(ninfecID,ninfecID),1)]=1
}
}
# Move infection
if(rand1>2/3){
infectID=infvector[(as.numeric(x)>0)]
ninfecID=infvector[(as.numeric(x)==0)]
if(length(infectID)>0 & length(ninfecID)>0){
x[sample(c(infectID,infectID),1)]=0
x[sample(c(ninfecID,ninfecID),1)]=1
}
}
# Add prior on birth year - exponentially less likely to update if infections outside
#if(inf.n>ageA[ii]){
#  a1=0.01*exp(1)*exp(-sum(x[1:(inf.n-ageA[ii])])) # EDIT infvector2 tweak this parameter to penalise more/less
#  if( a1 > runif(1) ){
#    historyA[ii,]=x
#  }
#}
historyA[ii,]=x
} # end loop over individuals
historyA
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Resample age - add 1, 0, -1 with equal probability
SampleAge<-function(pick,ageA){
b1=sapply(ageA[pick],function(x){x+sample(c(-1:1),1)})
ageA[pick]=b1
ageA
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Convert infection history to binary - not currently used
convert_binary <- function(x){sum(2^(which(rev(unlist(strsplit(as.character(x), "")) == 1))-1))}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ComputeProbability<-function(marg_likelihood,marg_likelihood_star){
# uniform priors
p_theta_star = 1
p_theta = 1
# probability symmetic
q_theta_given_theta_star = 1
q_theta_star_given_theta = 1
val = exp((marg_likelihood_star-marg_likelihood))*(p_theta_star/p_theta)*(q_theta_given_theta_star/q_theta_star_given_theta)
min(val, 1)
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SampleTheta<-function(theta_in,m,covartheta){
# sample new parameters from nearby:
theta_star = as.numeric(exp(rmvnorm(1,log(theta_in), covartheta)))
names(theta_star)=names(theta_in)
return(thetaS=theta_star)
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Metropolis-Hastings algorithm
run_mcmc<-function(test.yr,test_years,inf_years,strain_years,n_part,test.list,theta0,runs,varpart_prob,hist.true=NULL,switch1=2){
# DEBUG set params <<<
# hist.true=NULL; test.yr=c(2010,2011); runs=1; switch1=2; varpart_prob=0.05
test.n=length(test_years)
inf.n=length(inf_years)
nstrains=length(strain_years)
sample.index=strain_years-min(strain_years)+1
historyii=rbinom(inf.n, 1, 0.1) # dummy infection history
# Index variables
jj_year=match(test.yr,test_years)
testyear_index=match(test.yr,inf_years)
sample.n=length(jj_year)
# Specific MCMC parameters
nparam=length(theta)
npcov=rep(1,nparam)
cov_matrix_theta0 = diag(npcov)
thetatab=matrix(NA,nrow=(runs+1),ncol=length(theta))
colnames(thetatab)=names(theta)
thetatab[1,]=theta
historytab=matrix(NA,nrow=n_part,ncol=inf.n)
historytabCollect=historytab
age.tab=matrix(NA,nrow=n_part,ncol=1)
# Pick plausible initial conditions
if(is.null(hist.true)){
for(ii in 1:n_part){
historytab[ii,]=setuphistIC(ii,jj_year[1],inf.n,test.list,testyear_index) # Pick first test year
}
}else{
historytab=hist.true
}
colnames(historytab)=as.character(inf_years)
# Plausible intial ages - based on earliest strain in history
#age.tab=sapply(
#  apply(historytab,1,function(x){min(c(inf.n:1)[x==1])}),
#  function(y){ sample(y:80, 1, replace=T) })
# Preallocate matrices
likelihoodtab=matrix(-Inf,nrow=(runs+1),ncol=n_part)
accepttabT=rep(NA,(runs/2))
accepttabH=rep(NA,(runs))
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run MCMC
for (m in 1:runs){
# Adaptive covariance matrix
if(m==1){
epsilon0=0.01
#epsilon0=0
cov_matrix_theta=epsilon0*cov_matrix_theta0
#varpart_prob0=varpart_prob
}else{
epsilon0=min(1,exp(log(epsilon0)+(accept_rateT-0.234)*0.999^m))
#epsilon0=0
cov_matrix_theta=epsilon0*cov_matrix_theta0
}
# - - - - - - - - - - - - - - - -
# Resample parameters
#aTime=Sys.time() #TIMER 1
if(m %% switch1==1 | varpart_prob==0){
theta_star = SampleTheta(thetatab[m,], m,cov_matrix_theta) #resample theta
#age_star = age.tab
history_star = historytab
pickA=c(1:n_part)
}else{
pickA=NULL
pickA=sample(n_part, ceiling(varpart_prob*n_part)) # check that not length zero
#age_star = age.tab #SampleAge(pickA,age.tab) #resample age (not for now)
history_star = SampleHistory(historytab,pickA,inf.n,age_star,inf_years) #resample history
theta_star =thetatab[m,]
}
dmatrix=outputdmatrix(theta_star,inf_years) # Arrange parameters
# - - - - - - - - - - - - - - - -
# LIKELIHOOD function - Only calculate for updated history
#print(jj_year)
#print(testyear_index)
lik_val=likelihoodtab[m,]
for(ii in pickA){
# Set history to zero after test date
lik.ii=rep(NA,sample.n)
for(kk in 1:sample.n){
#DEBUG DEBUG set params <<<
#ii=1;kk=2;historyii=as.numeric(history_star[ii,])
lik.ii[kk]=estimatelik(ii,jj_year[kk],as.numeric(history_star[ii,]),dmatrix,theta_star,test.list,testyear_index[kk])
}
lik.ii
lik_val[ii]=sum(lik.ii)
#if(is.na(lik_val[ii])){lik_val[ii]=-Inf}
}
# - - - - - - - - - - - - - - - -
# Metropolis Hastings step
#print(pickA)
#print(age.tab)
#print(c(m,sum(likelihoodtab[m,]),sum(lik_val))) # PRINT LIKELIHOOD
output_prob = ComputeProbability(sum(likelihoodtab[m,]),sum(lik_val))
if(runif(1) < output_prob){
thetatab[m+1,] = theta_star
if(m %% switch1==0){historytab = history_star} # Only change if resampled
#if(m %% switch1==0){age.tab = age_star} # Only change if resampled
likelihoodtab[m+1,] = lik_val
if(m %% switch1!=0){accepttabT[(switch1-1)*(m+1)/switch1]=1}
}else{
thetatab[m+1,] = thetatab[m,]
likelihoodtab[m+1,] = likelihoodtab[m,]
if(m %% switch1!=0){accepttabT[(switch1-1)*(m+1)/switch1]=0}
}
if(m<100){
accept_rateT=0.234
}else{
accept_rateT=sum(accepttabT[1:((switch1-1)*(m+1)/switch1)])/((switch1-1)*(m+1)/switch1)
}
#Sys.time()-aTime  #TIMER 2
if(m %% min(runs,20) ==0){
historytabCollect=rbind(historytabCollect,historytab)
}
if(m %% min(runs,100) ==0){
print(c(m,accept_rateT,round(sum(likelihoodtab[m,]))))
save(likelihoodtab,thetatab,n_part,test.list,historytabCollect,age.tab,file=paste("posterior_sero_runs/outputR",test.yr[1],".RData",sep=""))
}
} #End runs loop
}
load("R_datasets/HaNam_data.RData")
#load("R_datasets/Simulated_data.RData")
# Plot simulation data vs history
#source("simulation_plots.R")
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,muShort=NA,sigma=NA,wane=NA)
theta0[["mu"]]=3
theta0[["sigma"]]=0.3
theta0[["tau1"]]=0.1
theta0[["tau2"]]=0.1
theta0[["muShort"]]=1
theta0[["wane"]]=0.1
theta=theta0
vp1=0.05 #probability individual infection history resampled
define.year=c(2011,2012)
# NEED TO RE INITIALISE DATAFRAME IF REPEAT RUN
run_mcmc(test.yr=define.year,runs=10000,hist.true=NULL,varpart_prob=vp1,test_years,inf_years,strain_years,n_part,test.list,theta0,switch1=2)
# Plot posteriors and compare to simulation
simDat=FALSE
source("simulation_diagnostics.R",local=TRUE)
# Model of serological dynamics - uses PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015)
# setwd("~/Documents/flu-model/sero_model/")
# setwd("./sero_model")
library(reshape2)
library(foreach)
library(doMC)
library(mvtnorm)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load data and functions (Fonville et al.)
#source("load_data.R")
source("sero_functions.R")
compile.c() # Compile c code
# logabs2(seq(-5, 5, by=2))
# - - - - - - - - - - - - -
# Generate simulated data
thetaSim=c(mu=4,tau1=0.3,tau2=0.1,muShort=1,sigma=0.3,wane=0.1)
npartM=100
simulate_data(test_years=seq(2010,2010),
inf_years=seq(1980,2010,1),
strain_years=seq(1980,2010,2),
n_part=npartM,thetastar=thetaSim,p.inf=0.1)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# INFERENCE MODEL
# Run MCMC for specific data set
load("R_datasets/HaNam_data.RData")
#load("R_datasets/Simulated_data.RData")
# Plot simulation data vs history
#source("simulation_plots.R")
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,muShort=NA,sigma=NA,wane=NA)
theta0[["mu"]]=2
theta0[["sigma"]]=0.3
theta0[["tau1"]]=0.1
theta0[["tau2"]]=0.1
theta0[["muShort"]]=1
theta0[["wane"]]=0.1
theta=theta0
vp1=0.05 #probability individual infection history resampled
define.year=c(2010,2011)
# NEED TO RE INITIALISE DATAFRAME IF REPEAT RUN
run_mcmc(test.yr=define.year,runs=1000,hist.true=NULL,varpart_prob=vp1,test_years,inf_years,strain_years,n_part,test.list,theta0,switch1=2)
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,muShort=NA,sigma=NA,wane=NA)
theta0[["mu"]]=2
theta0[["sigma"]]=0.3
theta0[["tau1"]]=0.05
theta0[["tau2"]]=0.1
theta0[["muShort"]]=2
theta0[["wane"]]=0.1
theta=theta0
vp1=0.05 #probability individual infection history resampled
define.year=c(2010,2011)
# NEED TO RE INITIALISE DATAFRAME IF REPEAT RUN
run_mcmc(test.yr=define.year,runs=200000,hist.true=NULL,varpart_prob=vp1,test_years,inf_years,strain_years,n_part,test.list,theta0,switch1=2)
load("R_datasets/HaNam_data.RData")
#load("R_datasets/Simulated_data.RData")
# Plot simulation data vs history
#source("simulation_plots.R")
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,muShort=NA,sigma=NA,wane=NA)
theta0[["mu"]]=2
theta0[["sigma"]]=0.3
theta0[["tau1"]]=0.05
theta0[["tau2"]]=0.1
theta0[["muShort"]]=2
theta0[["wane"]]=0.1
theta=theta0
vp1=0.05 #probability individual infection history resampled
define.year=c(2010,2011)
# NEED TO RE INITIALISE DATAFRAME IF REPEAT RUN
run_mcmc(test.yr=define.year,runs=200000,hist.true=NULL,varpart_prob=vp1,test_years,inf_years,strain_years,n_part,test.list,theta0,switch1=2)
# Model of serological dynamics - uses extended PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015-)
# Main execution code
setwd("~/Documents/flu-model/sero_model/")
# setwd("~/Dropbox/git/flu-model/sero_model")
library(reshape2)
library(mvtnorm)
library(MASS)
library(coda)
library(RColorBrewer)
library(magrittr)
library(plot3D)
library(colorspace)
library(foreach)
library(doMC)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
rm(list=ls(all=TRUE))
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load data and functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#source("load_data.R") # Reformat HaNam data and save to file
# make_fluscape_rdata(pathfssvn="~/fluscape/trunk/") # Reformat Flu B data and save to file
source("sero_functions.R")
source("posterior_analysis_flu.R")
source("sero_funcs_steven.r") # Load Flu B format
compile.c() # Compile c code
flutype0="H3HN"
if(flutype0=="H3FS"){ dy1=c(2009) }
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
if(flutype0=="B"){ dy1=c(2011,2012) }
if(flutype0=="H1"){ dy1=c(2009:2011) }
load.flu.map.data()
load("datasets/spline_fn.RData") # load spline function for map **NEED TO LOAD THIS before inference run**
install.packages("coda")
install.packages("RColorBrewer")
install.packages("plot3D")
install.packages("colorspace")
# Model of serological dynamics - uses extended PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015-)
# Main execution code
setwd("~/Documents/flu-model/sero_model/")
# setwd("~/Dropbox/git/flu-model/sero_model")
library(reshape2)
library(mvtnorm)
library(MASS)
library(coda)
library(RColorBrewer)
library(magrittr)
library(plot3D)
library(colorspace)
library(foreach)
library(doMC)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
rm(list=ls(all=TRUE))
source("sero_functions.R")
source("posterior_analysis_flu.R")
source("sero_funcs_steven.r") # Load Flu B format
compile.c() # Compile c code
flutype0="H3HN"
if(flutype0=="H3FS"){ dy1=c(2009) }
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
if(flutype0=="B"){ dy1=c(2011,2012) }
if(flutype0=="H1"){ dy1=c(2009:2011) }
load.flu.map.data()
load("datasets/spline_fn.RData") # load spline function for map **NEED TO LOAD THIS before inference run**
load.flu.map.data()
getwd()
# Model of serological dynamics - uses extended PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015-)
# Main execution code
setwd("~/Documents/flu-model/sero_model/")
# setwd("~/Dropbox/git/flu-model/sero_model")
library(reshape2)
library(mvtnorm)
library(MASS)
library(coda)
library(RColorBrewer)
library(magrittr)
library(plot3D)
library(colorspace)
library(foreach)
library(doMC)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
rm(list=ls(all=TRUE))
source("sero_functions.R")
source("posterior_analysis_flu.R")
source("sero_funcs_steven.r") # Load Flu B format
getwd()
compile.c() # Compile c code
# Model of serological dynamics - uses extended PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015-)
# Main execution code
setwd("~/Documents/flu-model/sero_model/")
# setwd("~/Dropbox/git/flu-model/sero_model")
library(reshape2)
library(mvtnorm)
library(MASS)
library(coda)
library(RColorBrewer)
library(magrittr)
library(plot3D)
library(colorspace)
library(foreach)
library(doMC)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
rm(list=ls(all=TRUE))
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load data and functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#source("load_data.R") # Reformat HaNam data and save to file
# make_fluscape_rdata(pathfssvn="~/fluscape/trunk/") # Reformat Flu B data and save to file
source("sero_functions.R")
source("posterior_analysis_flu.R")
source("sero_funcs_steven.r") # Load Flu B format
flutype0="H3HN"
if(flutype0=="H3FS"){ dy1=c(2009) }
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
if(flutype0=="B"){ dy1=c(2011,2012) }
if(flutype0=="H1"){ dy1=c(2009:2011) }
load.flu.map.data()
load("datasets/spline_fn.RData") # load spline function for map **NEED TO LOAD THIS before inference run**
# Run longitudinal inference on H3 HaNam data
flutype0="H3HN"
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
#for(kk in 1:4){
foreach(kk=1:4) %dopar% {
# Fits to spline if am.spl is defined
data.infer(year_test=dy1,mcmc.iterations=10,loadseed=kk,
flutype=flutype0,fix.param=c("tau1","vary.init"),fit.spline=am.spl,switch0=2,linearFn=T) #,"map.fit"
}
compile.c() # Compile c code
# Run longitudinal inference on H3 HaNam data
flutype0="H3HN"
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
#for(kk in 1:4){
foreach(kk=1:4) %dopar% {
# Fits to spline if am.spl is defined
data.infer(year_test=dy1,mcmc.iterations=10,loadseed=kk,
flutype=flutype0,fix.param=c("tau1","vary.init"),fit.spline=am.spl,switch0=2,linearFn=T) #,"map.fit"
}
kk=1
dy1
data.infer(year_test=dy1,mcmc.iterations=10,loadseed=kk,
flutype=flutype0,fix.param=c("tau1","vary.init"),fit.spline=am.spl,switch0=2,linearFn=T) #,"map.fit"
data.infer(year_test=dy1,mcmc.iterations=10,loadseed=kk,
flutype=flutype0,fix.param=c("tau1","vary.init"),fit.spline=am.spl,switch0=2,linearFn=T) #,"map.fit"
flutype0="H3HN"
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
#for(kk in 1:4){
foreach(kk=1:4) %dopar% {
# Fits to spline if am.spl is defined
data.infer(year_test=dy1,mcmc.iterations=1e2,loadseed=kk,
flutype=flutype0,fix.param=c("tau1","vary.init"),fit.spline=am.spl,switch0=2,linearFn=T) #,"map.fit"
}
# >>> IMPORTANT FOR TESTING RUNS
# Plot convergence for MCMC chains for H3 Vietnam
plot.multi.chain.posteriors(burnCut=0.25,flu.type="H3HN",fr.lim=F,linearFn=T)
plot.multi.chain.posteriors
# Run longitudinal inference on H3 HaNam data
flutype0="H3HN"
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
#for(kk in 1:4){
foreach(kk=1:3) %dopar% {
# Fits to spline if am.spl is defined
data.infer(year_test=dy1,mcmc.iterations=10,loadseed=kk,
flutype=flutype0,fix.param=c("tau1","vary.init"),fit.spline=am.spl,switch0=2,linearFn=F) #,"map.fit"
}
# Run longitudinal inference on H3 HaNam data
flutype0="H3HN"
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
#for(kk in 1:4){
foreach(kk=1:3) %dopar% {
# Fits to spline if am.spl is defined
data.infer(year_test=dy1,mcmc.iterations=1e4,loadseed=kk,
flutype=flutype0,fix.param=c("tau1","vary.init"),fit.spline=am.spl,switch0=2,linearFn=F) #,"map.fit"
}
plot.multi.chain.posteriors(burnCut=0.25,loadpick=c(1:3), flu.type="H3HN",fr.lim=F,linearFn=T)
plot.multi.chain.posteriors(burnCut=0.25,loadpick=c(1:3), flu.type="H3HN",fr.lim=F,linearFn=F)
