}
## All possible circulation times
strainIsolationTimes <- unique(fit_dat$inf_years)
##############
## BETA BINOMIAL PROPOSALS
## NOTE - this is not relevant if using history proposal 1
##############
## Change alpha and beta to change proposal distribution
## Setting to c(1,1) gives uniform distribution on total number of infections
#parTab[parTab$names %in% c("alpha","beta"),"values"] <- find_a_b(length(strainIsolationTimes),7,50)
parTab[parTab$names %in% c("alpha","beta"),"values"] <- c(0.75,4.5)
## Starting infection histories based on data
## Can use starting history using the algorithm in the bioarxiv paper or a new, sparser one
startInf <- setup_infection_histories_new(titreDat, ages, unique(fit_dat$inf_years), space=5,titre_cutoff=2)
#startInf <- setup_infection_histories_OLD(titreDat, unique(fit_dat$inf_years), rep(1,n_indiv), sample_prob=0.2, titre_cutoff=4)
startInf <- matrix(rep(rep(c(1,0,0,0,0),9),n_part),nrow=n_part) # Uniform history
if(LAMBDA){
if(!FLUSCAPE){
ages1 <- read.csv("~/Documents/serosolver/data/real/vietnam_ages.csv")
} else {
ages1 <- ages
}
version <- 4
n_alive <- sapply(strainIsolationTimes, function(x) length(ages[ages$DOB <= x,])/69)
tmp <- parTab[parTab$names == "lambda",]
for(i in 1:(length(strainIsolationTimes)-1)){
parTab <- rbind(parTab, tmp)
}
parTab[parTab$names == "lambda","upper_bound"] <- n_alive
parTab[parTab$names == "lambda","upper_start"] <- n_alive
} else {
version <- 1
}
## Generate starting parameters for the MCMC chain
startTab <- parTab
# for(i in 1:nrow(startTab)){
#   if(startTab[i,"fixed"] == 0){
#     startTab[i,"values"] <- runif(1,startTab[i,"lower_start"],
#                                   startTab[i,"upper_start"])
#   }
# }
## Multivariate proposals or univariate? Use univariate for now
covMat <- diag(nrow(parTab))
scale <- 0.5
w <- 1
mvrPars <- list(covMat, scale, w)
mvrPars <- NULL
#########################
## RUN MCMC
#########################
res <- run_MCMC(startTab, titreDat, mcmcPars, filename=filename,
create_post_func, mvrPars, PRIOR=NULL,version=version, 0.2,
fit_dat, ages=ages,
startInfHist=startInf)
#########################
parTab
devtools::load_all()
## How many individuals to fit to?
n_indiv <-69
FLUSCAPE <- FALSE
LAMBDA <- FALSE
## Which infection history proposal version to use?
## ********Note*********
## that this should be set to 1 if using the explicit FOI term
describe_proposals()
histProposal <- 1
## MCMC run time
mcmcPars <- c("iterations"=100,"popt"=0.44,"popt_hist"=0.44,"opt_freq"=1000,"thin"=1,"adaptive_period"=50000,
"save_block"=10,"thin2"=50,"histSampleProb"=1,"switch_sample"=2, "burnin"=0,
"nInfs"=1, "moveSize"=10, "histProposal"=histProposal, "histOpt"=1)
## Buckets indicates the time resolution of the analysis. Setting
## this to 1 uses annual epochs, whereas setting this to 12 gives
## monthly epochs
buckets <- 1
## The general output filename
filename <- "chains/vietnam_lambda"
## Read in parameter table to simulate from and change waning rate if necessary
## Use "parTab.csv" if not using explicit lambda term, "parTab_lambdas.csv" otherwise
if(LAMBDA){
parTab <- read.csv("~/Documents/serosolver/inputs/parTab_lambda.csv",stringsAsFactors=FALSE)
} else {
read.csv("~/Documents/serosolver/inputs/parTab.csv",stringsAsFactors=FALSE)
}
## Possible sampling times
samplingTimes <- seq(2010*buckets, 2015*buckets, by=1)
## Antigenic map for cross reactivity parameters
fit_dat <- read.csv("~/Documents/serosolver/data/antigenic_maps/antigenicMap_vietnam.csv")
## Read in Fluscape or Vietnam data
if(FLUSCAPE){
fluscapeDat <- read.csv("data/real/fluscape_data.csv",stringsAsFactors=FALSE)
fluscapeAges <- read.csv("data/real/fluscape_ages.csv")
## Remove individuals with NA for DOB
na_indiv <- fluscapeAges[which(is.na(fluscapeAges$DOB)),"individual"]
fluscapeDat <- fluscapeDat[-na_indiv,]
fluscapeAges <- fluscapeAges[-na_indiv,]
## Take random subset of individuals
indivs <- sample(unique(fluscapeDat$individual),n_indiv)
indivs <- indivs[order(indivs)]
indivs <- unique(fluscapeAges$individual)
titreDat <- fluscapeDat[fluscapeDat$individual %in% indivs,]
ages <- fluscapeAges[fluscapeAges$individual %in% indivs,]
titreDat$individual <- match(titreDat$individual, indivs)
ages$individual <- match(ages$individual, indivs)
titreDat <- titreDat[,c("individual", "samples", "virus", "titre", "run", "group")]
} else {
titreDat <- read.csv("data/real/vietnam_data.csv")
ages <- data.frame(individual=1:length(unique(titreDat$individual)),DOB=1940)
fit_dat <- fit_dat[fit_dat$inf_years <= 2012,]
}
## All possible circulation times
strainIsolationTimes <- unique(fit_dat$inf_years)
FLUSCAPE
parTab[parTab$names %in% c("alpha","beta"),"values"] <- c(0.75,4.5)
parTab=mcmcPars
parTab[parTab$names %in% c("alpha","beta"),"values"] <- c(0.75,4.5)
## Starting infection histories based on data
## Can use starting history using the algorithm in the bioarxiv paper or a new, sparser one
startInf <- setup_infection_histories_new(titreDat, ages, unique(fit_dat$inf_years), space=5,titre_cutoff=2)
#startInf <- setup_infection_histories_OLD(titreDat, unique(fit_dat$inf_years), rep(1,n_indiv), sample_prob=0.2, titre_cutoff=4)
startInf <- matrix(rep(rep(c(1,0,0,0,0),9),n_part),nrow=n_part) # Uniform history
if(LAMBDA){
if(!FLUSCAPE){
ages1 <- read.csv("~/Documents/serosolver/data/real/vietnam_ages.csv")
} else {
ages1 <- ages
}
version <- 4
n_alive <- sapply(strainIsolationTimes, function(x) length(ages[ages$DOB <= x,])/69)
tmp <- parTab[parTab$names == "lambda",]
for(i in 1:(length(strainIsolationTimes)-1)){
parTab <- rbind(parTab, tmp)
}
parTab[parTab$names == "lambda","upper_bound"] <- n_alive
parTab[parTab$names == "lambda","upper_start"] <- n_alive
} else {
version <- 1
}
## Generate starting parameters for the MCMC chain
startTab <- parTab
# for(i in 1:nrow(startTab)){
#   if(startTab[i,"fixed"] == 0){
#     startTab[i,"values"] <- runif(1,startTab[i,"lower_start"],
#                                   startTab[i,"upper_start"])
#   }
# }
## Multivariate proposals or univariate? Use univariate for now
covMat <- diag(nrow(parTab))
scale <- 0.5
w <- 1
mvrPars <- list(covMat, scale, w)
mvrPars <- NULL
#########################
## RUN MCMC
#########################
res <- run_MCMC(startTab, titreDat, mcmcPars, filename=filename,
create_post_func, mvrPars, PRIOR=NULL,version=version, 0.2,
fit_dat, ages=ages,
startInfHist=startInf)
#########################
mcmcPars
#########################
res <- run_MCMC(startTab, titreDat, mcmcPars, filename=filename,
create_post_func, mvrPars, PRIOR=NULL,version=version, 0.2,
fit_dat, ages=ages,
startInfHist=startInf)
# Model of serological dynamics - uses extended PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015-)
# Main execution code
setwd("~/Documents/flu-model/sero_model/")
# setwd("~/Dropbox/git/flu-model/sero_model")
library(reshape2)
library(mvtnorm)
library(MASS)
library(coda)
library(RColorBrewer)
library(magrittr)
library(plot3D)
library(colorspace)
library(foreach)
library(doMC)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
rm(list=ls(all=TRUE))
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load data and functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# source("load_data_Vietnam.R") # Reformat HaNam data and save to file
# source("load_data_China.R") # Reformat FluScape and save to file
source("sero_functions.R")
source("posterior_analysis_flu.R")
compile.c() # Compile c code
flutype0="H3HN"
if(flutype0=="H3FS"){ dy1=c(2009) }
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
if(flutype0=="B"){ dy1=c(2011,2012) }
if(flutype0=="H1"){ dy1=c(2009:2011) }
load.flu.map.data()
load("datasets/spline_fn.RData") # load spline function for map **NEED TO LOAD THIS before inference run**
simDat=F;loadseed=2;year_test=c(2007:2012);plotmap=F;fr.lim=T;flu.type="H3HN"; plot.corr=F; linearFn=T
if(simDat==F){loadseed=paste(loadseed,"_",flu.type,sep="")}
if(simDat==T){load(paste("R_datasets/Simulated_data_",loadseed,".RData",sep=""))}
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,"_lin",linearFn,".RData",sep=""))
if(flu.type=="H3HN" & simDat==F){
yob.data=data.frame(read.csv("datasets/HaNam_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})}
if((flu.type=="H3FS"  | flu.type== "H3FS_HI" ) & simDat==F){
yob.data=data.frame(read.csv("datasets/FluScape_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})
}
if(simDat==T){
yob.data=cbind(rep(1,n_part),rep(1,n_part)) # Import age distribution
n.alive=n_part+0*inf_years
}
if(simDat==T){ par(mfrow=c(5,2)) }else{ if(flu.type=="H3FS" | flu.type=="H3FS_HI" ){par(mfrow=c(3,2))}else{par(mfrow=c(4,2))} }
par(mar = c(4,4,1,1))
par(mgp=c(1.8,0.6,0))
colA=rgb(0.8,0.8,0.8)
# Define lengths and sizes of inputs
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
x=max(lik.tot[1:runsPOST])
#plot(as.data.frame(thetatab)$sigma[1:runsPOST],type="l",ylab="parameter")
# - - - - - - -
# Calculate ESS by burn-in
runs1=ceiling(0.25*runsPOST)
calculate.ESS<-function(runs1){
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]; ltheta=length(thetaT[["mu"]]); thin.theta=thetaT[seq(1,ltheta,switch1),]
ESS.calc=effectiveSize(thin.theta); ESS.calc
}
ESS.calc=calculate.ESS(runs1)
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]
ltheta=length(thetaT[["mu"]])
thin.theta=thetaT[seq(1,ltheta,switch1),] # Needs to be = switch1 as this is how often theta is reasmpled
ESS.label2<-function(x){signif(as.numeric(x),3)}
ESS.label<-function(x){""}
write.csv(melt(thin.theta,0),"plots/theta_output.csv")
write.csv(melt(thin.theta,0),"plot_simulations/theta_output.csv")
seq(1,ltheta,switch1)
seq(1,ltheta,switch1)*switch1
swicth1
switch1
length(thin.theta)
dim(thin.theta)
length(seq(1,ltheta,switch1))
theta_out = thin.theta
theta_out = cbind(seq(1,ltheta,switch1),rep(1,length(seq(1,ltheta,switch1))),theta_out)
head(theta_out)
melt(thin.theta,0)
head(thin.theta)
theta_out = thin.theta
theta_out = cbind(seq(1,ltheta,switch1),rep(1,length(seq(1,ltheta,switch1))),theta_out)
theta_out = melt(thin.theta,0)
head(theta_out)
theta_out = thin.theta
theta_out1 = cbind(seq(1,ltheta,switch1),rep(1,length(seq(1,ltheta,switch1))),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
head(theta_out1)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(thin.theta,c("sampno","chain"))
# DEBUG output values
theta_out = thin.theta
theta_out1 = cbind(seq(1,ltheta,switch1),rep(1,length(seq(1,ltheta,switch1))),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
head(theta_out)
runs1
# DEBUG output values
theta_out = thin.theta
theta_out1 = cbind(runs1+seq(1,ltheta,switch1),rep(1,length(seq(1,ltheta,switch1))),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
head(theta_out)
# DEBUG output values
theta_out = thin.theta
theta_out1 = cbind(runs1+seq(1,ltheta,switch1)-1,rep(1,length(seq(1,ltheta,switch1))),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
head(theta_out)
dim(theta_out)
length(thin.theta)
dim(thin.theta)
theta_out = thin.theta[seq(1,length(thin.theta),100),]
theta_out
dim(theta_out)
seq(1,length(thin.theta),100)
seq(1,length(thin.theta[,1]),100)
# DEBUG output values
pick_theta = seq(1,length(thin.theta[,1]),100)
theta_out = thin.theta[pick_theta,]
theta_out1 = cbind(runs1+pick_theta-1,rep(1,length(pick_theta)),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
head(theta_out)
theta_out$sampno
max(theta_out$sampno)
simDat=F;loadseed=2;year_test=c(2007:2012);plotmap=F;fr.lim=T;flu.type="H3HN"; plot.corr=F; linearFn=T
if(simDat==F){loadseed=paste(loadseed,"_",flu.type,sep="")}
if(simDat==T){load(paste("R_datasets/Simulated_data_",loadseed,".RData",sep=""))}
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,"_lin",linearFn,".RData",sep=""))
if(flu.type=="H3HN" & simDat==F){
yob.data=data.frame(read.csv("datasets/HaNam_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})}
if((flu.type=="H3FS"  | flu.type== "H3FS_HI" ) & simDat==F){
yob.data=data.frame(read.csv("datasets/FluScape_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})
}
if(simDat==T){
yob.data=cbind(rep(1,n_part),rep(1,n_part)) # Import age distribution
n.alive=n_part+0*inf_years
}
if(simDat==T){ par(mfrow=c(5,2)) }else{ if(flu.type=="H3FS" | flu.type=="H3FS_HI" ){par(mfrow=c(3,2))}else{par(mfrow=c(4,2))} }
par(mar = c(4,4,1,1))
par(mgp=c(1.8,0.6,0))
colA=rgb(0.8,0.8,0.8)
# Define lengths and sizes of inputs
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
x=max(lik.tot[1:runsPOST])
#plot(as.data.frame(thetatab)$sigma[1:runsPOST],type="l",ylab="parameter")
# - - - - - - -
# Calculate ESS by burn-in
runs1=ceiling(0.25*runsPOST)
calculate.ESS<-function(runs1){
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]; ltheta=length(thetaT[["mu"]]); thin.theta=thetaT[seq(1,ltheta,switch1),]
ESS.calc=effectiveSize(thin.theta); ESS.calc
}
ESS.calc=calculate.ESS(runs1)
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]
ltheta=length(thetaT[["mu"]])
thin.theta=thetaT[seq(1,ltheta,switch1),] # Needs to be = switch1 as this is how often theta is reasmpled
ESS.label2<-function(x){signif(as.numeric(x),3)}
ESS.label<-function(x){""}
# DEBUG output values
pick_theta = seq(1,length(thin.theta[,1]),100)
theta_out = thin.theta[pick_theta,]
theta_out1 = cbind(runs1+pick_theta-1,rep(1,length(pick_theta)),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
head(theta_out)
dim(theta_out)
head(historytabCollect)
historytabCollect[((round(0.2*hist.sample)*n_part)+1):(hist.sample*n_part),]
length(historytabCollect[,1])/n_part # need this sample value because table is stacked
hist.sample=length(historytabCollect[,1])/n_part # need this sample value because table is stacked
hist.sample
hist.sample=length(historytabCollect[,1])/n_part # need this sample value because table is stacked
historytabCollect[((round(0.2*hist.sample)*n_part)+1):(hist.sample*n_part),]
hist.sample=length(historytabCollect[,1])/n_part # need this sample value because table is stacked
hist_out = historytabCollect[((round(0.2*hist.sample)*n_part)+1):(hist.sample*n_part),]
head(hist_out)
dim(hist_out)
hist_out = historytabCollect
dim(hist_out)
# Model of serological dynamics - uses extended PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015-)
# Main execution code
setwd("~/Documents/flu-model/sero_model/")
# setwd("~/Dropbox/git/flu-model/sero_model")
library(reshape2)
library(mvtnorm)
library(MASS)
library(coda)
library(RColorBrewer)
library(magrittr)
library(plot3D)
library(colorspace)
library(foreach)
library(doMC)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
rm(list=ls(all=TRUE))
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load data and functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# source("load_data_Vietnam.R") # Reformat HaNam data and save to file
# source("load_data_China.R") # Reformat FluScape and save to file
source("sero_functions.R")
source("posterior_analysis_flu.R")
compile.c() # Compile c code
flutype0="H3HN"
if(flutype0=="H3FS"){ dy1=c(2009) }
if(flutype0=="H3HN"){ dy1=c(2007:2012) }
if(flutype0=="B"){ dy1=c(2011,2012) }
if(flutype0=="H1"){ dy1=c(2009:2011) }
load.flu.map.data()
load("datasets/spline_fn.RData") # load spline function for map **NEED TO LOAD THIS before inference run**
simDat=F;loadseed=2;year_test=c(2007:2012);plotmap=F;fr.lim=T;flu.type="H3HN"; plot.corr=F; linearFn=T
if(simDat==F){loadseed=paste(loadseed,"_",flu.type,sep="")}
if(simDat==T){load(paste("R_datasets/Simulated_data_",loadseed,".RData",sep=""))}
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,"_lin",linearFn,".RData",sep=""))
if(flu.type=="H3HN" & simDat==F){
yob.data=data.frame(read.csv("datasets/HaNam_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})}
if((flu.type=="H3FS"  | flu.type== "H3FS_HI" ) & simDat==F){
yob.data=data.frame(read.csv("datasets/FluScape_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})
}
if(simDat==T){
yob.data=cbind(rep(1,n_part),rep(1,n_part)) # Import age distribution
n.alive=n_part+0*inf_years
}
if(simDat==T){ par(mfrow=c(5,2)) }else{ if(flu.type=="H3FS" | flu.type=="H3FS_HI" ){par(mfrow=c(3,2))}else{par(mfrow=c(4,2))} }
par(mar = c(4,4,1,1))
par(mgp=c(1.8,0.6,0))
colA=rgb(0.8,0.8,0.8)
# Define lengths and sizes of inputs
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
x=max(lik.tot[1:runsPOST])
#plot(as.data.frame(thetatab)$sigma[1:runsPOST],type="l",ylab="parameter")
# - - - - - - -
# Calculate ESS by burn-in
runs1=ceiling(0.25*runsPOST)
calculate.ESS<-function(runs1){
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]; ltheta=length(thetaT[["mu"]]); thin.theta=thetaT[seq(1,ltheta,switch1),]
ESS.calc=effectiveSize(thin.theta); ESS.calc
}
ESS.calc=calculate.ESS(runs1)
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]
ltheta=length(thetaT[["mu"]])
thin.theta=thetaT[seq(1,ltheta,switch1),] # Needs to be = switch1 as this is how often theta is reasmpled
ESS.label2<-function(x){signif(as.numeric(x),3)}
ESS.label<-function(x){""}
# DEBUG output values
pick_theta = seq(1,length(thin.theta[,1]),100)
theta_out = thin.theta[pick_theta,]
theta_out1 = cbind(runs1+pick_theta-1,rep(1,length(pick_theta)),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]
theta_out = 1:length(thetaT$mu)
# DEBUG output values
pick_theta = 1:length(thetaT$mu)
theta_out = thetaT[pick_theta,]
theta_out1 = cbind(runs1+pick_theta-1,rep(1,length(pick_theta)),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
head(theta_out)
# DEBUG output values
pick_theta = 1:length(thetaT$mu)
theta_out = thetaT[pick_theta,]
theta_out1 = cbind(pick_theta,rep(1,length(pick_theta)),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
hist_out = historytabCollect
head(theta_out1)
head(theta_out)
write.csv(theta_out,"plot_simulations/theta_output.csv")
write.csv(historytabCollect,"plot_simulations/hist_output.csv")
write.csv(thetaT,"plot_simulations/theta_output.csv")
pick_theta = seq(1,length(thetaT$mu),20)
theta_out = thetaT[pick_theta,]
theta_out1 = cbind(pick_theta,rep(1,length(pick_theta)),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
dim(theta_out1)
dim(historytabCollect)
dim(historytabCollect)[1]/69
20*dim(historytabCollect)[1]/69
dim(theta_out)
dim(thetaT)
simDat=F;loadseed=1;year_test=c(2007:2012);plotmap=F;fr.lim=T;flu.type="H3HN"; plot.corr=F; linearFn=T
if(simDat==F){loadseed=paste(loadseed,"_",flu.type,sep="")}
if(simDat==T){load(paste("R_datasets/Simulated_data_",loadseed,".RData",sep=""))}
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,"_lin",linearFn,".RData",sep=""))
if(flu.type=="H3HN" & simDat==F){
yob.data=data.frame(read.csv("datasets/HaNam_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})}
if((flu.type=="H3FS"  | flu.type== "H3FS_HI" ) & simDat==F){
yob.data=data.frame(read.csv("datasets/FluScape_YOB.csv",header=FALSE)) # Import age distribution
n.alive=sapply(inf_years,function(x){sum(yob.data<=x)})
}
if(simDat==T){
yob.data=cbind(rep(1,n_part),rep(1,n_part)) # Import age distribution
n.alive=n_part+0*inf_years
}
if(simDat==T){ par(mfrow=c(5,2)) }else{ if(flu.type=="H3FS" | flu.type=="H3FS_HI" ){par(mfrow=c(3,2))}else{par(mfrow=c(4,2))} }
par(mar = c(4,4,1,1))
par(mgp=c(1.8,0.6,0))
colA=rgb(0.8,0.8,0.8)
# Define lengths and sizes of inputs
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
x=max(lik.tot[1:runsPOST])
#plot(as.data.frame(thetatab)$sigma[1:runsPOST],type="l",ylab="parameter")
# - - - - - - -
# Calculate ESS by burn-in
runs1=ceiling(0.25*runsPOST)
calculate.ESS<-function(runs1){
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]; ltheta=length(thetaT[["mu"]]); thin.theta=thetaT[seq(1,ltheta,switch1),]
ESS.calc=effectiveSize(thin.theta); ESS.calc
}
ESS.calc=calculate.ESS(runs1)
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]
ltheta=length(thetaT[["mu"]])
thin.theta=thetaT[seq(1,ltheta,switch1),] # Needs to be = switch1 as this is how often theta is reasmpled
ESS.label2<-function(x){signif(as.numeric(x),3)}
ESS.label<-function(x){""}
# DEBUG output values
pick_theta = seq(1,length(thetaT$mu),20)
theta_out = thetaT[pick_theta,]
theta_out1 = cbind(pick_theta,rep(1,length(pick_theta)),theta_out)
names(theta_out1) = c("sampno","chain",names(theta_out))
theta_out = melt(theta_out1,c("sampno","chain"))
hist_out = historytabCollect
write.csv(thetaT,"plot_simulations/theta_output.csv")
dim(thetaT)
dim(thetatab)
pick_theta = seq(1,length(thetatab$mu),20)
theta_out1 = as.data.frame(thetatab)
theta_out1
length(historytabCollect[,1])
