# Construct matrices for plots
datasetP=datasetP[!is.na(datasetP[,1]),] # Exclude non-participants from matrix - for plot
datasetP[datasetMAIN$Round!=round1,1:7]=NA # Pick only contacts in this round - for plot
# - - - - - - - - - - - - - - - - - -
# Analysis tools
# - - - - - - - - - - - - - - - - - -
# Calculate mutual contacts
mutual=1
if(mutual==1){
datasetM=datasetP
for(ii in 1:length(datasetP[,1])){
# Find mutual links - check indexing carefully!
datasetM[ii,2:7]=sapply(datasetM[ii,2:7],function(x){  if( !is.na(match(x,datasetP[,1])) ){if( sum(datasetM[match(x,datasetP[,1]),!is.na(datasetM[match(x,datasetP[,1]),])] ==datasetP[ii,1])==1 ){x}else{NA}}else{NA}  })
}
if(paired1!=1){
#partp=datasetM[datasetMAIN$Round==round1,1]   # Makes sure only paired participants are included
#datasetM=matrix(match(datasetM, partp),ncol=7) # Converts to index
}
NetworkMatrix=datasetM
}else{
# Adjust so only contacts in this round plotted
if(paired1==1){
datasetM=datasetP
partp=datasetM[dataset1$Round==round1,1]
NetworkMatrix=matrix(match(datasetM, partp),ncol=7) # Note that this reorders things - so need to use original labels from datasetRound!
}else{
NetworkMatrix=datasetP
}
}
# Distribution of contacts
distn_contact=apply(datasetP[!is.na(datasetP[,1]),2:7],1,function(x){ sum(!is.na(x)) } )
#hist(distn_contact)
# - - - - - - - - - - - - - - - - - -
# Plotting tools
# - - - - - - - - - - - - - - - - - -
# Convert to network readable code
x1=apply(NetworkMatrix, 1, function(x) c(rbind(rep(x[1],6),x[2:7])) )
dim(x1)<-NULL
x2=matrix(x1,ncol=2,byrow=TRUE)
x2=x2[!is.na(x2[,2]),]
x2=x2[(x2[,1]-x2[,2])!=0,]
write.csv(x2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
# Plot graph
g2<-graph.edgelist(x2)
#set.seed(103)
set.seed(103)
#coord <- layout.fruchterman.reingold(g2)
coord <- layout.kamada.kawai(g2)
#coord <- layout.circle(g2)
if(round1==1){
coord1=coord
}else{
coord <- coord1
}
write.csv(x2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
#write.csv(get.adjacency(g2,sparse=FALSE),paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_matrix_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
par(mai=c(0,0,0,0)) #Flu colours
col1=datasetRound$Flu
col1[is.na(col1)]=0
col1flu=sapply(col1,function(x){ifelse(x==1,'red','white')})
# MF colours
col1=datasetRound$MF
col1[is.na(col1)]=0
col1mf=sapply(col1,function(x){ifelse(x==2,'pink','cyan')})
col1mf=sapply(col1,function(x){ifelse(x==2,'grey','white')})
shapeMFcol=sapply(col1,function(x){ifelse(x==2,'grey','white')})
shapeMF=sapply(col1,function(x){ifelse(x==2,'circle','square')})
colby=3
colname=c("all","flu","MF")
coltab=cbind(datasetP[datasetMAIN$Round==round1,1],rep('white',length(col1flu)),col1flu,col1mf)
coltab=coltab[match(sort(as.numeric(coltab[,1])),as.numeric(coltab[,1])),] # Sort by colour
pickcol=coltab[,colby+1]
if(round1==1){
pickcol1=pickcol
}else{
pickcol <- pickcol1
}
#plot(g2,layout=coord,vertex.size=8,vertex.label=NA,vertex.color=pickcol,vertex.label.cex=0.5,vertex.label.family="",edge.arrow.size=0,edge.width=2) #,
plot(g2,layout=coord,vertex.size=6,vertex.shape=shapeMF,vertex.color=shapeMFcol,vertex.label=NA,edge.arrow.size=0,edge.width=2)
#plot(g2,layout=coord,vertex.size=8,vertex.label=sort(as.numeric(coltab[,1])),vertex.color=pickcol,vertex.label.cex=0.5,vertex.label.family="",edge.arrow.size=0,edge.width=2) #,
write.csv(coltab,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),"_col.csv",sep=""))
dev.copy(pdf,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Network_s",school1,"_r",round1,"_",colname[colby],".pdf",sep=""),width=6,height=6)
dev.off()
library(igraph)
library(reshape)
# Define school
school1=4
paired1=2
# - - - - - - - - - - - - - - - - - -
# Load and clean dataset
# - - - - - - - - - - - - - - - - - -
dataset1=read.csv("~/Dropbox/LSHTM/Schools_project_2014/Data_sets/Survey_data_entry/Data_entry_2_21_10_15.csv")
schooltab=c("Highgate","St. Paul's","St. Bons","Lakes")
schoolID=schooltab[school1]
dataset1=dataset1[dataset1$School==schoolID,]
dataset0a=cbind(c(1:length(dataset1[,1])),paste(dataset1[,4],dataset1[,5],sep="_"))
# Merge name strings
for(i in 1:6){
dataset0a=cbind(dataset0a,paste(dataset1[,6+2*(i-1)+1],dataset1[,6+2*i],sep="_"))
}
# Replace blank names with IDs
dataset0a[dataset0a[,2]=="_",2]=paste("_ID_",dataset0a[dataset0a[,2]=="_",1],sep="")
dataset0a=as.data.frame(dataset0a)
names(dataset0a)=c("ID","p1","c1","c2","c3","c4","c5","c6")
# Clean names in data
source("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/cleaning_data.R")
dataset0b=clean_fun(dataset0a,school1)
#dataset0b=dataset0a
# Convert data into matrix and anonymise
dataset1a=as.matrix(dataset0b[,2:8])
idlist=unique(dataset1a[,1])
# Find participant names that appear in all rounds
name_twice=sapply(idlist,function(x){if( (sum(dataset1a[dataset1$Round==1,1]==x)+sum(dataset1a[dataset1$Round==2,1]==x))==2){TRUE}else{FALSE} })
name_thrice=sapply(idlist,function(x){if( (sum(dataset1a[dataset1$Round==1,1]==x)+sum(dataset1a[dataset1$Round==2,1]==x)+sum(dataset1a[dataset1$Round==3,1]==x))==3){TRUE}else{FALSE} })
name_four=sapply(idlist,function(x){if( (sum(dataset1a[dataset1$Round==1,1]==x)+sum(dataset1a[dataset1$Round==2,1]==x)+sum(dataset1a[dataset1$Round==3,1]==x)+sum(dataset1a[dataset1$Round==4,1]==x))==4){TRUE}else{FALSE} })
if(paired1==2){idlist=idlist[name_twice]} # **** Only paired data used ****
if(paired1==3){idlist=idlist[name_thrice]} # **** Only 3-link data used ****
if(paired1==4){idlist=idlist[name_four]} # **** Only 4-link data used ****
idlistAll=sort(as.character(unique(melt(dataset1a,"ID")$value)))
reorderN=c(match(idlist,idlistAll),match(idlistAll[!idlistAll %in% idlist],idlistAll))
idlistAll=sort(idlistAll[reorderN])
#idlistAll=unique(c(idlist,idlistAll)) #Ensure participants first
#idlistAll[idlistAll=="_"]=NA
idlistAll=unique(c(idlist,idlistAll)) #Ensure paired participants first
idlistAll[idlistAll=="_"]=NA
datasetP=matrix(match(dataset1a, idlist),ncol=7) # Need to use participants only in plot
# This function to check clean data: sort(idlistAll)
# PICK ROUND TO PLOT HERE
round1=1
# Change to ensure only draw from people in both surveys
#datasetP=matrix(match(dataset1a, idlist),ncol=7)
datasetRound=dataset1[dataset1$Round==round1 & !is.na(datasetP[,1]),] # Characteristics for participants in this round - for plot. Make sure
datasetMAIN=dataset1[!is.na(datasetP[,1]),] # Characteristics for participants - for file
# - - - - - - - - -
# Output data csvs
# - - - - - - - - -
output_paired<-function(){ # Paired anonymised data across all rounds
dataset1f=dataset1a[!is.na(datasetP[,1]),] # contact data for participants - for file
datasetPA=matrix(match(dataset1f, idlistAll),ncol=7) # anonymised contact data - for file
nameround=dataset1$Round[!is.na(datasetP[,1])] # list of round - for file
# Output full dataset - both rounds paired data only
datacol1=cbind(datasetMAIN$MF,datasetMAIN$Travel,datasetMAIN$X,datasetMAIN$X.1,datasetMAIN$X.2,datasetMAIN$Club,datasetMAIN$X.3,datasetMAIN$X.4,datasetMAIN$Flu,datasetMAIN$X.5,datasetMAIN$Siblings,datasetMAIN$Convo
)
datacol2=cbind(nameround,datasetPA,datacol1[,])
colnames(datacol2)=c("Round","Participant","Contact_1","Contact_2","Contact_3","Contact_4","Contact_5","Contact_6","Sex","Travel","Travel","Travel","Travel","Clubs","Clubs","Clubs","Flu","Flu","Siblings","Conversation")
datacol2[is.na(datacol2)]=""
datacol2=as.data.frame(datacol2)
datacol2$Round=as.numeric(levels(datacol2$Round)[datacol2$Round])
datacol2$Participant=as.numeric(levels(datacol2$Participant)[datacol2$Participant])
datacol2=datacol2[order(datacol2$Round,datacol2$Participant),]
write.csv(datacol2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_s",school1,".csv",sep=""))
}
output_round<-function(){  # Data for this round only
idlist=unique(dataset1a[,1])
idlistPaired=idlist[name_twice]
idlistAll=sort(as.character(unique(melt(dataset1a,"ID")$value)))
reorderN=c(match(idlist,idlistAll),match(idlistAll[!idlistAll %in% idlist],idlistAll))
idlistAll=sort(idlistAll[reorderN])
idlistAll=unique(c(idlist,idlistAll))
idlistAll[idlistAll=="_"]=NA
datasetP=matrix(match(dataset1a, idlist),ncol=7)
datasetMAIN=dataset1[!is.na(datasetP[,1]),] # Characteristics for participants - for file
dataset1f=dataset1a[!is.na(datasetP[,1]),] # contact data for participants - for file
datasetPA=matrix(match(dataset1f, idlistAll),ncol=7) # anonymised contact data - for file
nameround=dataset1$Round[!is.na(datasetP[,1])] # list of round - for file
# Output full dataset - both rounds paired data only
datacol1=cbind(datasetMAIN$MF,datasetMAIN$Travel,datasetMAIN$X,datasetMAIN$X.1,datasetMAIN$X.2,datasetMAIN$Club,datasetMAIN$X.3,datasetMAIN$X.4,datasetMAIN$Flu,datasetMAIN$X.5,datasetMAIN$Siblings,datasetMAIN$Convo
)
datacol2=cbind(nameround,datasetPA,datacol1[,])
colnames(datacol2)=c("Round","Participant","Contact_1","Contact_2","Contact_3","Contact_4","Contact_5","Contact_6","Sex","Travel","Travel","Travel","Travel","Clubs","Clubs","Clubs","Flu","Flu","Siblings","Conversation")
datacol2[is.na(datacol2)]=""
datacol2=as.data.frame(datacol2)
datacol2$Round=as.numeric(levels(datacol2$Round)[datacol2$Round])
datacol2$Participant=as.numeric(levels(datacol2$Participant)[datacol2$Participant])
datacol2=datacol2[order(datacol2$Round,datacol2$Participant),]
write.csv(datacol2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_All_",school1,".csv",sep=""))
}
# Construct matrices for plots
datasetP=datasetP[!is.na(datasetP[,1]),] # Exclude non-participants from matrix - for plot
datasetP[datasetMAIN$Round!=round1,1:7]=NA # Pick only contacts in this round - for plot
# - - - - - - - - - - - - - - - - - -
# Analysis tools
# - - - - - - - - - - - - - - - - - -
# Calculate mutual contacts
mutual=1
if(mutual==1){
datasetM=datasetP
for(ii in 1:length(datasetP[,1])){
# Find mutual links - check indexing carefully!
datasetM[ii,2:7]=sapply(datasetM[ii,2:7],function(x){  if( !is.na(match(x,datasetP[,1])) ){if( sum(datasetM[match(x,datasetP[,1]),!is.na(datasetM[match(x,datasetP[,1]),])] ==datasetP[ii,1])==1 ){x}else{NA}}else{NA}  })
}
if(paired1!=1){
#partp=datasetM[datasetMAIN$Round==round1,1]   # Makes sure only paired participants are included
#datasetM=matrix(match(datasetM, partp),ncol=7) # Converts to index
}
NetworkMatrix=datasetM
}else{
# Adjust so only contacts in this round plotted
if(paired1==1){
datasetM=datasetP
partp=datasetM[dataset1$Round==round1,1]
NetworkMatrix=matrix(match(datasetM, partp),ncol=7) # Note that this reorders things - so need to use original labels from datasetRound!
}else{
NetworkMatrix=datasetP
}
}
# Distribution of contacts
distn_contact=apply(datasetP[!is.na(datasetP[,1]),2:7],1,function(x){ sum(!is.na(x)) } )
#hist(distn_contact)
# - - - - - - - - - - - - - - - - - -
# Plotting tools
# - - - - - - - - - - - - - - - - - -
# Convert to network readable code
x1=apply(NetworkMatrix, 1, function(x) c(rbind(rep(x[1],6),x[2:7])) )
dim(x1)<-NULL
x2=matrix(x1,ncol=2,byrow=TRUE)
x2=x2[!is.na(x2[,2]),]
x2=x2[(x2[,1]-x2[,2])!=0,]
write.csv(x2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
# Plot graph
g2<-graph.edgelist(x2)
#set.seed(103)
set.seed(103)
#coord <- layout.fruchterman.reingold(g2)
coord <- layout.kamada.kawai(g2)
#coord <- layout.circle(g2)
if(round1==1){
coord1=coord
}else{
coord <- coord1
}
write.csv(x2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
#write.csv(get.adjacency(g2,sparse=FALSE),paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_matrix_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
par(mai=c(0,0,0,0)) #Flu colours
col1=datasetRound$Flu
col1[is.na(col1)]=0
col1flu=sapply(col1,function(x){ifelse(x==1,'red','white')})
# MF colours
col1=datasetRound$MF
col1[is.na(col1)]=0
col1mf=sapply(col1,function(x){ifelse(x==2,'pink','cyan')})
col1mf=sapply(col1,function(x){ifelse(x==2,'grey','white')})
shapeMFcol=sapply(col1,function(x){ifelse(x==2,'grey','white')})
shapeMF=sapply(col1,function(x){ifelse(x==2,'circle','square')})
colby=3
colname=c("all","flu","MF")
coltab=cbind(datasetP[datasetMAIN$Round==round1,1],rep('white',length(col1flu)),col1flu,col1mf)
coltab=coltab[match(sort(as.numeric(coltab[,1])),as.numeric(coltab[,1])),] # Sort by colour
pickcol=coltab[,colby+1]
if(round1==1){
pickcol1=pickcol
}else{
pickcol <- pickcol1
}
#plot(g2,layout=coord,vertex.size=8,vertex.label=NA,vertex.color=pickcol,vertex.label.cex=0.5,vertex.label.family="",edge.arrow.size=0,edge.width=2) #,
plot(g2,layout=coord,vertex.size=6,vertex.shape=shapeMF,vertex.color=shapeMFcol,vertex.label=NA,edge.arrow.size=0,edge.width=2)
#plot(g2,layout=coord,vertex.size=8,vertex.label=sort(as.numeric(coltab[,1])),vertex.color=pickcol,vertex.label.cex=0.5,vertex.label.family="",edge.arrow.size=0,edge.width=2) #,
write.csv(coltab,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),"_col.csv",sep=""))
dev.copy(pdf,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Network_s",school1,"_r",round1,"_",colname[colby],".pdf",sep=""),width=6,height=6)
dev.off()
sort(idlistAll)
library(igraph)
library(reshape)
# Define school
school1=4
paired1=4
# - - - - - - - - - - - - - - - - - -
# Load and clean dataset
# - - - - - - - - - - - - - - - - - -
dataset1=read.csv("~/Dropbox/LSHTM/Schools_project_2014/Data_sets/Survey_data_entry/Data_entry_2_21_10_15.csv")
schooltab=c("Highgate","St. Paul's","St. Bons","Lakes")
schoolID=schooltab[school1]
dataset1=dataset1[dataset1$School==schoolID,]
dataset0a=cbind(c(1:length(dataset1[,1])),paste(dataset1[,4],dataset1[,5],sep="_"))
# Merge name strings
for(i in 1:6){
dataset0a=cbind(dataset0a,paste(dataset1[,6+2*(i-1)+1],dataset1[,6+2*i],sep="_"))
}
# Replace blank names with IDs
dataset0a[dataset0a[,2]=="_",2]=paste("_ID_",dataset0a[dataset0a[,2]=="_",1],sep="")
dataset0a=as.data.frame(dataset0a)
names(dataset0a)=c("ID","p1","c1","c2","c3","c4","c5","c6")
# Clean names in data
source("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/cleaning_data.R")
dataset0b=clean_fun(dataset0a,school1)
#dataset0b=dataset0a
# Convert data into matrix and anonymise
dataset1a=as.matrix(dataset0b[,2:8])
idlist=unique(dataset1a[,1])
# Find participant names that appear in all rounds
name_twice=sapply(idlist,function(x){if( (sum(dataset1a[dataset1$Round==1,1]==x)+sum(dataset1a[dataset1$Round==2,1]==x))==2){TRUE}else{FALSE} })
name_thrice=sapply(idlist,function(x){if( (sum(dataset1a[dataset1$Round==1,1]==x)+sum(dataset1a[dataset1$Round==2,1]==x)+sum(dataset1a[dataset1$Round==3,1]==x))==3){TRUE}else{FALSE} })
name_four=sapply(idlist,function(x){if( (sum(dataset1a[dataset1$Round==1,1]==x)+sum(dataset1a[dataset1$Round==2,1]==x)+sum(dataset1a[dataset1$Round==3,1]==x)+sum(dataset1a[dataset1$Round==4,1]==x))==4){TRUE}else{FALSE} })
if(paired1==2){idlist=idlist[name_twice]} # **** Only paired data used ****
if(paired1==3){idlist=idlist[name_thrice]} # **** Only 3-link data used ****
if(paired1==4){idlist=idlist[name_four]} # **** Only 4-link data used ****
idlistAll=sort(as.character(unique(melt(dataset1a,"ID")$value)))
reorderN=c(match(idlist,idlistAll),match(idlistAll[!idlistAll %in% idlist],idlistAll))
idlistAll=sort(idlistAll[reorderN])
#idlistAll=unique(c(idlist,idlistAll)) #Ensure participants first
#idlistAll[idlistAll=="_"]=NA
idlistAll=unique(c(idlist,idlistAll)) #Ensure paired participants first
idlistAll[idlistAll=="_"]=NA
datasetP=matrix(match(dataset1a, idlist),ncol=7) # Need to use participants only in plot
# This function to check clean data: sort(idlistAll)
# PICK ROUND TO PLOT HERE
round1=1
# Change to ensure only draw from people in both surveys
#datasetP=matrix(match(dataset1a, idlist),ncol=7)
datasetRound=dataset1[dataset1$Round==round1 & !is.na(datasetP[,1]),] # Characteristics for participants in this round - for plot. Make sure
datasetMAIN=dataset1[!is.na(datasetP[,1]),] # Characteristics for participants - for file
# - - - - - - - - -
# Output data csvs
# - - - - - - - - -
output_paired<-function(){ # Paired anonymised data across all rounds
dataset1f=dataset1a[!is.na(datasetP[,1]),] # contact data for participants - for file
datasetPA=matrix(match(dataset1f, idlistAll),ncol=7) # anonymised contact data - for file
nameround=dataset1$Round[!is.na(datasetP[,1])] # list of round - for file
# Output full dataset - both rounds paired data only
datacol1=cbind(datasetMAIN$MF,datasetMAIN$Travel,datasetMAIN$X,datasetMAIN$X.1,datasetMAIN$X.2,datasetMAIN$Club,datasetMAIN$X.3,datasetMAIN$X.4,datasetMAIN$Flu,datasetMAIN$X.5,datasetMAIN$Siblings,datasetMAIN$Convo
)
datacol2=cbind(nameround,datasetPA,datacol1[,])
colnames(datacol2)=c("Round","Participant","Contact_1","Contact_2","Contact_3","Contact_4","Contact_5","Contact_6","Sex","Travel","Travel","Travel","Travel","Clubs","Clubs","Clubs","Flu","Flu","Siblings","Conversation")
datacol2[is.na(datacol2)]=""
datacol2=as.data.frame(datacol2)
datacol2$Round=as.numeric(levels(datacol2$Round)[datacol2$Round])
datacol2$Participant=as.numeric(levels(datacol2$Participant)[datacol2$Participant])
datacol2=datacol2[order(datacol2$Round,datacol2$Participant),]
write.csv(datacol2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_s",school1,".csv",sep=""))
}
output_round<-function(){  # Data for this round only
idlist=unique(dataset1a[,1])
idlistPaired=idlist[name_twice]
idlistAll=sort(as.character(unique(melt(dataset1a,"ID")$value)))
reorderN=c(match(idlist,idlistAll),match(idlistAll[!idlistAll %in% idlist],idlistAll))
idlistAll=sort(idlistAll[reorderN])
idlistAll=unique(c(idlist,idlistAll))
idlistAll[idlistAll=="_"]=NA
datasetP=matrix(match(dataset1a, idlist),ncol=7)
datasetMAIN=dataset1[!is.na(datasetP[,1]),] # Characteristics for participants - for file
dataset1f=dataset1a[!is.na(datasetP[,1]),] # contact data for participants - for file
datasetPA=matrix(match(dataset1f, idlistAll),ncol=7) # anonymised contact data - for file
nameround=dataset1$Round[!is.na(datasetP[,1])] # list of round - for file
# Output full dataset - both rounds paired data only
datacol1=cbind(datasetMAIN$MF,datasetMAIN$Travel,datasetMAIN$X,datasetMAIN$X.1,datasetMAIN$X.2,datasetMAIN$Club,datasetMAIN$X.3,datasetMAIN$X.4,datasetMAIN$Flu,datasetMAIN$X.5,datasetMAIN$Siblings,datasetMAIN$Convo
)
datacol2=cbind(nameround,datasetPA,datacol1[,])
colnames(datacol2)=c("Round","Participant","Contact_1","Contact_2","Contact_3","Contact_4","Contact_5","Contact_6","Sex","Travel","Travel","Travel","Travel","Clubs","Clubs","Clubs","Flu","Flu","Siblings","Conversation")
datacol2[is.na(datacol2)]=""
datacol2=as.data.frame(datacol2)
datacol2$Round=as.numeric(levels(datacol2$Round)[datacol2$Round])
datacol2$Participant=as.numeric(levels(datacol2$Participant)[datacol2$Participant])
datacol2=datacol2[order(datacol2$Round,datacol2$Participant),]
write.csv(datacol2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_All_",school1,".csv",sep=""))
}
# Construct matrices for plots
datasetP=datasetP[!is.na(datasetP[,1]),] # Exclude non-participants from matrix - for plot
datasetP[datasetMAIN$Round!=round1,1:7]=NA # Pick only contacts in this round - for plot
# - - - - - - - - - - - - - - - - - -
# Analysis tools
# - - - - - - - - - - - - - - - - - -
# Calculate mutual contacts
mutual=1
if(mutual==1){
datasetM=datasetP
for(ii in 1:length(datasetP[,1])){
# Find mutual links - check indexing carefully!
datasetM[ii,2:7]=sapply(datasetM[ii,2:7],function(x){  if( !is.na(match(x,datasetP[,1])) ){if( sum(datasetM[match(x,datasetP[,1]),!is.na(datasetM[match(x,datasetP[,1]),])] ==datasetP[ii,1])==1 ){x}else{NA}}else{NA}  })
}
if(paired1!=1){
#partp=datasetM[datasetMAIN$Round==round1,1]   # Makes sure only paired participants are included
#datasetM=matrix(match(datasetM, partp),ncol=7) # Converts to index
}
NetworkMatrix=datasetM
}else{
# Adjust so only contacts in this round plotted
if(paired1==1){
datasetM=datasetP
partp=datasetM[dataset1$Round==round1,1]
NetworkMatrix=matrix(match(datasetM, partp),ncol=7) # Note that this reorders things - so need to use original labels from datasetRound!
}else{
NetworkMatrix=datasetP
}
}
# Distribution of contacts
distn_contact=apply(datasetP[!is.na(datasetP[,1]),2:7],1,function(x){ sum(!is.na(x)) } )
#hist(distn_contact)
# - - - - - - - - - - - - - - - - - -
# Plotting tools
# - - - - - - - - - - - - - - - - - -
# Convert to network readable code
x1=apply(NetworkMatrix, 1, function(x) c(rbind(rep(x[1],6),x[2:7])) )
dim(x1)<-NULL
x2=matrix(x1,ncol=2,byrow=TRUE)
x2=x2[!is.na(x2[,2]),]
x2=x2[(x2[,1]-x2[,2])!=0,]
write.csv(x2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
# Plot graph
g2<-graph.edgelist(x2)
#set.seed(103)
set.seed(103)
#coord <- layout.fruchterman.reingold(g2)
coord <- layout.kamada.kawai(g2)
#coord <- layout.circle(g2)
if(round1==1){
coord1=coord
}else{
coord <- coord1
}
write.csv(x2,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
#write.csv(get.adjacency(g2,sparse=FALSE),paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_matrix_s",school1,"_r",round1,ifelse(mutual==1,"m",""),".csv",sep=""))
par(mai=c(0,0,0,0)) #Flu colours
col1=datasetRound$Flu
col1[is.na(col1)]=0
col1flu=sapply(col1,function(x){ifelse(x==1,'red','white')})
# MF colours
col1=datasetRound$MF
col1[is.na(col1)]=0
col1mf=sapply(col1,function(x){ifelse(x==2,'pink','cyan')})
col1mf=sapply(col1,function(x){ifelse(x==2,'grey','white')})
shapeMFcol=sapply(col1,function(x){ifelse(x==2,'grey','white')})
shapeMF=sapply(col1,function(x){ifelse(x==2,'circle','square')})
colby=3
colname=c("all","flu","MF")
coltab=cbind(datasetP[datasetMAIN$Round==round1,1],rep('white',length(col1flu)),col1flu,col1mf)
coltab=coltab[match(sort(as.numeric(coltab[,1])),as.numeric(coltab[,1])),] # Sort by colour
pickcol=coltab[,colby+1]
if(round1==1){
pickcol1=pickcol
}else{
pickcol <- pickcol1
}
#plot(g2,layout=coord,vertex.size=8,vertex.label=NA,vertex.color=pickcol,vertex.label.cex=0.5,vertex.label.family="",edge.arrow.size=0,edge.width=2) #,
plot(g2,layout=coord,vertex.size=6,vertex.shape=shapeMF,vertex.color=shapeMFcol,vertex.label=NA,edge.arrow.size=0,edge.width=2)
#plot(g2,layout=coord,vertex.size=8,vertex.label=sort(as.numeric(coltab[,1])),vertex.color=pickcol,vertex.label.cex=0.5,vertex.label.family="",edge.arrow.size=0,edge.width=2) #,
write.csv(coltab,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Data_plot_s",school1,"_r",round1,ifelse(mutual==1,"m",""),"_col.csv",sep=""))
dev.copy(pdf,paste("~/Dropbox/LSHTM/Schools_project_2014/School_data_14/output_data/Network_s",school1,"_r",round1,"_",colname[colby],".pdf",sep=""),width=6,height=6)
dev.off()
sort(idlistAll)
# Model of serological dynamics - uses PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015)
# setwd("~/Documents/flu-model/sero_model/")
# setwd("./sero_model")
library(reshape2)
library(foreach)
library(doMC)
library(mvtnorm)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load data and functions (Fonville et al.)
#source("load_data.R")
source("sero_functions.R")
compile.c() # Compile c code
# logabs2(seq(-5, 5, by=2))
setwd("~/Documents/flu-model/sero_model/")
# Model of serological dynamics - uses PLOS Biology model (Kucharski et al. 2015)
# Author: AJ Kucharski (2015)
# setwd("~/Documents/flu-model/sero_model/")
# setwd("./sero_model")
library(reshape2)
library(foreach)
library(doMC)
library(mvtnorm)
registerDoMC(4)  #change the 2 to your number of CPU cores
getDoParWorkers()
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load data and functions (Fonville et al.)
#source("load_data.R")
source("sero_functions.R")
compile.c() # Compile c code
# logabs2(seq(-5, 5, by=2))
load("R_datasets/HaNam_data.RData")
#load("R_datasets/Simulated_data.RData")
# Plot simulation data vs history
#source("simulation_plots.R")
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,wane=NA,sigma=NA,muShort=NA)
theta0[["mu"]]=3
theta0[["sigma"]]=0.3
theta0[["tau1"]]=0.1
theta0[["tau2"]]=0.1
theta0[["muShort"]]=2
theta0[["wane"]]=0.1
theta=theta0
vp1=0.05 #probability individual infection history resampled
define.year=c(2010,2011)
# NEED TO RE INITIALISE DATAFRAME IF REPEAT RUN
run_mcmc(test.yr=define.year,runs=20000,hist.true=NULL,varpart_prob=vp1,test_years,inf_years,strain_years,n_part,test.list,theta0,switch1=2)
# Plot posteriors and compare to simulation
simDat=FALSE
source("simulation_diagnostics.R",local=TRUE)
load("R_datasets/HaNam_data.RData")
#load("R_datasets/Simulated_data.RData")
# Plot simulation data vs history
#source("simulation_plots.R")
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,wane=NA,sigma=NA,muShort=NA)
theta0[["mu"]]=3
theta0[["sigma"]]=0.3
theta0[["tau1"]]=0.1
theta0[["tau2"]]=0.1
theta0[["muShort"]]=2
theta0[["wane"]]=0.1
theta=theta0
vp1=0.05 #probability individual infection history resampled
define.year=c(2010,2011)
# NEED TO RE INITIALISE DATAFRAME IF REPEAT RUN
run_mcmc(test.yr=define.year,runs=50000,hist.true=NULL,varpart_prob=vp1,test_years,inf_years,strain_years,n_part,test.list,theta0,switch1=2)
# Plot posteriors and compare to simulation
simDat=FALSE
source("simulation_diagnostics.R",local=TRUE)
