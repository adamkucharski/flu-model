}
dev.copy(pdf,paste("plot_simulations/posterior_compare",paste(define.year.vec,"_",collapse="",sep=""),".pdf",sep=""),width=12,height=8)
dev.off()
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run multi-chain diagnostics
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
plot.multi.chain.posteriors<-function(simDat=F,flutype="H3",loadpick=c(1:4),burnCut=0.5,year_test=c(2007:2012),plotmap=F,f.lim=F){
# simDat=F;year_test=c(2007:2012);plotmap=F;f.lim=T;flutype="H3"; loadpick=c(1:4); burnCut=0.5
storeMu = NULL
storeMu2 = NULL
storeLik = NULL
storeSigma = NULL
storeSigma2 = NULL
storeTau = NULL
storeTau2 = NULL
storeWane = NULL
col.list=list(col1=rgb(0.9,0.6,0),col2=rgb(0.2,0,0.8),col3=rgb(0.1,0.6,0.2),col4=rgb(1,0.4,1),col5=rgb(0.8,0,0.2))
for(loadseed in loadpick){
loadseedA=paste(loadseed,"_",flutype,sep="")
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseedA,".RData",sep=""))
# Define lengths and sizes of inputs
lik.tot=rowSums(likelihoodtab)
runsPOST=min(8e5, length(lik.tot[lik.tot!=-Inf]) )
maxlik=max(lik.tot[1:runsPOST])
#plot(as.data.frame(thetatab)$mu[runs1:runsPOST],type="l",ylab="mu")
# - - - - - - -
# Calculate ESS by burn-in
runs1=ceiling(0*runsPOST)
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]
ltheta=length(thetaT[["mu"]])
thin.theta=thetaT[seq(1,ltheta,switch1),]
lik.totA=lik.tot[runs1:runsPOST]
thin.lik = lik.totA[seq(1,ltheta,switch1)]
storeLik = rbind(storeLik,thin.lik)
storeMu = rbind(storeMu,thin.theta[["mu"]])
storeMu2 = rbind(storeMu2,thin.theta[["muShort"]])
storeSigma = rbind(storeSigma,thin.theta[["sigma"]])
storeSigma2 = rbind(storeSigma2,thin.theta[["sigma2"]])
storeWane = rbind(storeWane,thin.theta[["wane"]])
storeTau = rbind(storeTau,thin.theta[["tau1"]])
storeTau2 = rbind(storeTau2,thin.theta[["tau2"]])
}
# Plot MCMC chains
par(mfrow=c(4,2))
par(mar = c(4,4,1,1))
par(mgp=c(1.8,0.6,0))
colA=rgb(0.8,0.8,0.8)
plot(storeLik[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="likelihood",ylim=c(maxlik-1000,maxlik+100)); for(ii in 2:length(loadpick)){ lines(storeLik[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(-100000,100),col="gray",lty=2)
plot(storeWane[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="wane",ylim=c(0,5)); for(ii in 2:length(loadpick)){ lines(storeWane[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(0,100),col="gray",lty=2)
plot(storeMu[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="mu",ylim=c(1.5,2.5)); for(ii in 2:length(loadpick)){ lines(storeMu[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(0,100),col="gray",lty=2)
plot(storeMu2[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="mu2",ylim=c(0,30)); for(ii in 2:length(loadpick)){ lines(storeMu2[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(0,100),col="gray",lty=2)
plot(storeSigma[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="sigma",ylim=c(0,0.7)); for(ii in 2:length(loadpick)){ lines(storeSigma[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(0,100),col="gray",lty=2)
plot(storeSigma2[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="sigma2",ylim=c(0,0.2)); for(ii in 2:length(loadpick)){ lines(storeSigma2[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(0,100),col="gray",lty=2)
plot(storeTau[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="tau1",ylim=c(0,0.1)); for(ii in 2:length(loadpick)){ lines(storeTau[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(0,100),col="gray",lty=2)
plot(storeTau2[1,],type="l",col=col.list[[1]],xlab="iteration",ylab="tau2",ylim=c(0,0.1)); for(ii in 2:length(loadpick)){ lines(storeTau2[ii,],type="l",col=col.list[[ii]]) }
lines(c(burnCut*ltheta/switch1,burnCut*ltheta/switch1),c(0,100),col="gray",lty=2)
dev.copy(png,paste("plot_simulations/MCMC_chains",ifelse(simDat==T,"SIM",""),"_np",n_part,"_yr",paste(year_test,"_",collapse="",sep=""),loadseed,".png",sep=""),units="cm",width=15,height=20,res=300)
dev.off()
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Plot expected titres using sampled posterior estimates against true titres
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# plot.posterior.titres(loadseed="SIM",simDat=T,define.year=c(2007:2012))
plot.posterior.titres<-function(loadseed=1,year_test=c(2007:2012),flu.type,simDat=F,btstrap=5,plotRes=F){
if(simDat==F){
if(flutype=="H3"){load("R_datasets/HaNam_data.RData")}
if(flutype=="B"){load("R_datasets/Fluscape_data.RData")}
if(flutype=="H1"){load("R_datasets/HK_data.RData")}
loadseed=1 # DEBUG
loadseed=paste(loadseed,"_",flutype,sep="")
}else{
load(paste("R_datasets/Simulated_data_",loadseed,".RData",sep=""))
test.list=test.listSim
hist.true=historytabSim
}
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,".RData",sep="")) # Note that this includes test.listPost
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
runs1=ceiling(0.2*runsPOST)
# Set up matrices to store -- need btstrap >1
n.strains=length(strain_years) # this loads from main_model.R
n.test=length(test.yr)
n.inf=length(inf_years)
store.mcmc.test.data=array(NA, dim=c(btstrap,n_part,n.strains,n.test,2)) # Store expected titres for each test year
store.mcmc.hist.data=array(NA, dim=c(btstrap,n_part,n.inf,n.test)) # Store history for each test year
# - - - - - - - - - - - -
# Sample from MCMC runs to get stored matrices of expected titre and estimated infection years
for(sampk in 1:btstrap){
pickA=sample(c(runs1:runsPOST),1)
pickAhist=ceiling(pickA/20)+1 # check which history this specifies
hist.sample=historytabCollect[((pickAhist-1)*n_part+1):(pickAhist*n_part),1:n.inf]
theta.max=as.data.frame(thetatab)[pickA,]
for(pickyr in 1:n.test){
# Note here that inf_years and strain_years are loads from main_model.R
# Output expected titre - could include Poisson measurement uncertainty here?
#print("Need to add antigenic.map.in to SIMULATION") ?
simulate_data(test.yr[pickyr],historytabPost=hist.sample,
inf_years,
strain_years,
n_part,thetastar=theta.max,p.inf=0.1,
#pmask=c("sigma2"), # For old fitted data, need to specify that sigma2 wasn't fitted
linD=F)
load("R_datasets/Simulated_dataPost_1.RData")
# Mask infections after test year
for(ii0 in 1:n_part){
sim.titre=test.listSim[[ii0]][[1]] # sort sample years - drawn from simulated data above
hist.sampleB=hist.sample;  hist.sampleB[,as.numeric(colnames(hist.sample))>test.yr[pickyr]]=0 # don't show infections after test year
store.mcmc.test.data[sampk,ii0,,pickyr,1]= min(inf_years)-1+sort(sim.titre["sample.index",]) # Sampled strain years
s.titre=sim.titre["titredat",order(sim.titre["sample.index",])]
store.mcmc.test.data[sampk,ii0,,pickyr,2]=s.titre # Sampled expected titre
#store.mcmc.test.data[sampk,ii0,,pickyr,2]=rpois(length(s.titre),lambda=s.titre) # Sampled expected titre - include Poisson noise
store.mcmc.hist.data[sampk,ii0,,pickyr]=hist.sampleB[ii0,] # Sampled history
}  # end loop over participants
} # end loop over test years
} # end bootstrap loop
# - - - - - - - - - - - - - - - - - - -
# Plot histogram of estimated vs true titre
if(plotRes==T){
compTab = NULL
for(pickyr in 1:n.test){
for(ii0 in 1:n_part){ # Check more than one strain per year
if(!is.null(dim(store.mcmc.test.data[,ii0,,pickyr,2]))){
estT = apply(store.mcmc.test.data[,ii0,,pickyr,2],2,median)
}else{
estT = sapply(store.mcmc.test.data[,ii0,,pickyr,2],median)
}
truT = test.list[[ii0]][[pickyr]][2,]
compTab = c(compTab, estT - truT)
}
}
compTab = as.numeric(compTab); compTab = compTab[!is.na(compTab)]
par(mfrow=c(1,1))
par(mar = c(5,5,1,1))
hist(compTab , breaks = seq(-10.5,10.5,1) , col =rgb(0.8,0.8,0.8),main=NULL,xlab="expected titre - observed titre")
dev.copy(pdf,paste("plot_simulations/titre_compare/Residuals_",loadseed,".pdf",sep=""),width=6,height=4)
dev.off()
}
# - - - - - - - - - - - - - - - - - - -
# Plot figures from MCMC posteriors
for(pickyr in 1:n.test){
par(mfrow=c(2,5)); par(mar = c(5,5,1,1))
# Mask infections after test year
for(ii0 in 1:n_part){
simtitreX=store.mcmc.test.data[,ii0,,pickyr,1] # pick out years
simtitreY=store.mcmc.test.data[,ii0,,pickyr,2] # pick out estimates
hist.sample=store.mcmc.hist.data[,ii0,,pickyr] # for participant ii0 in year pickyr
plot(inf_years,8*hist.sample[1,],type="l",ylim=c(0,9),col='white',xlab="year",ylab="titre")
# Sample from infection history
for(ksamp in 1:btstrap){
for(jj in 1:n.inf){
lines(min(inf_years)-1+c(jj,jj),c(-1,12*hist.sample[ksamp,jj]-1),col=rgb(0,0,0,1/(2*btstrap)),lwd=2) # Plot estimated infections
}
}
# Calculate credible interval for expected titres
if(!is.null(dim(simtitreY))){ # Check more than one strain per year
medP=apply(simtitreY,2,function(x){median(x)})
ciP1=apply(simtitreY,2,function(x){quantile(x,0.025)})
ciP2=apply(simtitreY,2,function(x){quantile(x,0.975)})
polygon(c(simtitreX[1,],rev(simtitreX[1,])),c(ciP1,rev(ciP2)),lty=0,col=rgb(0,0.3,1,0.2))
lines(simtitreX[1,],medP,pch=1,col='blue')
points(simtitreX[1,],medP,pch=19,cex=0.5,col='blue')
}else{
medP=median(simtitreY)
ciP1=quantile(simtitreY,0.025)
ciP2=quantile(simtitreY,0.975)
#polygon(c(simtitreX,rev(simtitreX)),c(ciP1,rev(ciP2)),lty=0,col=rgb(0,0.3,1,0.2))
lines(c(simtitreX[1],simtitreX[1]),c(ciP1,ciP2),pch=1,col='blue')
points(simtitreX[1],medP,pch=19,cex=0.5,col='blue')
}
# Plot true titres
points(min(inf_years)-1+test.list[[ii0]][[pickyr]][4,],test.list[[ii0]][[pickyr]][2,],pch=1,col='red')
# Plot true infections if simulation
if(simDat==T){
histSim1=hist.true[ii0,]
histSim1[inf_years>year_test[pickyr]]=0 # don't show infections after test year
lenhis=rep(0,length(histSim1))
for(jj in 1:length(lenhis)){
lines(min(inf_years)-1+c(jj,jj),c(10*histSim1[jj]-2,12*histSim1[jj]-2),lwd=2,col=rgb(0,0.5,0))
}
}
if(ii0 %% 10==0){
dev.copy(pdf,paste("plot_simulations/titre_compare/sim",ii0,"P_",pickyr,".pdf",sep=""),width=12,height=6)
dev.off()
}
}  # end loop over participants
} # end loop over test years
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# FIGURE PLOT Plot expected titres using sampled posterior estimates against true titres
plot.posterior.titres.select<-function(loadseed=1,year_test=c(2007:2012),flu.type,simDat=F,btstrap=5,part_pick=c(31,57,25),year_pick=c(2008:2010)){
# year_pick=c(2008:2010);part_pick=c(15,31,57)
if(simDat==F){
if(flutype=="H3"){load("R_datasets/HaNam_data.RData")}
if(flutype=="B"){load("R_datasets/Fluscape_data.RData")}
if(flutype=="H1"){load("R_datasets/HK_data.RData")}
loadseed=1 # DEBUG
loadseed=paste(loadseed,"_",flutype,sep="")
}else{
load(paste("R_datasets/Simulated_data_",loadseed,".RData",sep=""))
test.list=test.listSim
hist.true=historytabSim
}
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,".RData",sep="")) # Note that this includes test.listPost
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
runs1=ceiling(0.2*runsPOST)
# Set up matrices to store -- need btstrap >1
n.strains=length(strain_years) # this loads from main_model.R
n.testMatch=match(year_pick,test.yr)
n.test=length(year_pick)
n.inf=length(inf_years)
n.ppart=length(part_pick)
store.mcmc.test.data=array(NA, dim=c(btstrap,n.ppart,n.strains,n.test,2)) # Store expected titres for each test year
store.mcmc.hist.data=array(NA, dim=c(btstrap,n.ppart,n.inf,n.test)) # Store history for each test year
# - - - - - - - - - - - -
# Sample from MCMC runs to get stored matrices of expected titre and estimated infection years
for(sampk in 1:btstrap){
pickA=sample(c(runs1:runsPOST),1)
pickAhist=ceiling(pickA/20)+1 # check which history this specifies
hist.sample=historytabCollect[((pickAhist-1)*n_part+1):(pickAhist*n_part),1:n.inf]
theta.max=as.data.frame(thetatab)[pickA,]
for(pickyr in 1:n.test){
# Note here that inf_years and strain_years are loads from main_model.R
# Output expected titre - could include Poisson measurement uncertainty here?
simulate_data(year_pick[pickyr],historytabPost=hist.sample,
inf_years,
strain_years,
n_part,thetastar=theta.max,p.inf=0.1,
#pmask=c("sigma2"), # For old fitted data, need to specify that sigma2 wasn't fitted
linD=F)
load("R_datasets/Simulated_dataPost_1.RData")
# Mask infections after test year
for(ii0 in 1:n.ppart){
sim.titre=test.listSim[[ part_pick[ii0] ]][[1]] # sort sample years - drawn from simulated data above
hist.sampleB=hist.sample;  hist.sampleB[,as.numeric(colnames(hist.sample))> year_pick[pickyr] ]=0 # don't show infections after test year
store.mcmc.test.data[sampk,ii0,,pickyr,1]= min(inf_years)-1+sort(sim.titre["sample.index",]) # Sampled strain years
s.titre=sim.titre["titredat",order(sim.titre["sample.index",])]
store.mcmc.test.data[sampk,ii0,,pickyr,2]=s.titre # Sampled expected titre
#store.mcmc.test.data[sampk,ii0,,pickyr,2]=rpois(length(s.titre),lambda=s.titre) # Sampled expected titre - include Poisson noise
store.mcmc.hist.data[sampk,ii0,,pickyr]=hist.sampleB[ part_pick[ii0] ,] # Sampled history
}  # end loop over participants
} # end loop over test years
} # end bootstrap loop
# - - - - - - - - - - - -
# Plot figures from MCMC posteriors
par(mfrow=c(3,3)); #layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))
par(mgp=c(1.8,0.6,0))
ymax=8.2 ; titleN = 1
for(ii0 in 1:n.ppart){
for(pickyr in 1:n.test){
simtitreX=store.mcmc.test.data[,ii0,,pickyr,1]
simtitreY=store.mcmc.test.data[,ii0,,pickyr,2]
hist.sample=store.mcmc.hist.data[,ii0,,pickyr] # for participant ii0 in year pickyr
#if(ii0 ==3 & pickyr == 1 ){par(mar = c(5,5,1,1))}
#par(mar = c(2,2,1,1)) #B L T R
if(ii0 < 3 & pickyr > 1){
par(mar = c(1,0,1,1))
plot(inf_years,8*hist.sample[1,],type="l",ylim=c(0,ymax),col='white',xlab=ifelse(ii0==3,"",""),ylab=ifelse(pickyr==1,"",""),xaxt="n",yaxt="n",main=ifelse(ii0==1,year_pick[pickyr],""))
axis(side = 1, at = inf_years, labels = FALSE, tck = -0.01)
}
if(ii0 == 3 & pickyr > 1){
par(mar = c(2,0,1,1))
plot(inf_years,8*hist.sample[1,],type="l",ylim=c(0,ymax),col='white',xlab=ifelse(ii0==3,"",""),ylab=ifelse(pickyr==1,"",""),yaxt="n")
axis(side = 1, at = inf_years, labels = FALSE, tck = -0.01)
}
if(pickyr == 1 & ii0 < 3){
par(mar = c(1,2,1,1))
plot(inf_years,8*hist.sample[1,],type="l",ylim=c(0,ymax),col='white',xlab=ifelse(ii0==3,"",""),ylab=ifelse(pickyr==1,"",""),xaxt="n",main=ifelse(ii0==1,year_pick[pickyr],""))
axis(side = 1, at = inf_years, labels = FALSE, tck = -0.01)
}
if(pickyr == 1 & ii0 ==3){
par(mar = c(2,2,1,1))
plot(inf_years,8*hist.sample[1,],type="l",ylim=c(0,ymax),col='white',xlab=ifelse(ii0==3,"",""),ylab=ifelse(pickyr==1,"",""))
axis(side = 1, at = inf_years, labels = FALSE, tck = -0.01)
}
# Sample from infection history
for(jj in 1:n.inf){
lines(min(inf_years)-1+c(jj,jj),c(-1,11-1),col=rgb(0,0,0,sum(hist.sample[,jj])/btstrap),lwd=2) # Plot estimated infections
}
# Calculate credible interval for expected titres
medP=apply(simtitreY,2,function(x){median(x)}); ciP195=apply(simtitreY,2,function(x){quantile(x,0.025)}); ciP295=apply(simtitreY,2,function(x){quantile(x,0.975)});
ciP1=apply(simtitreY,2,function(x){quantile(x,0.25)}); ciP2=apply(simtitreY,2,function(x){quantile(x,0.75)})
#alpha50 = qchisq(0.5, 1); alpha95 = qchisq(0.95, 1); medP=apply(simtitreY,2,function(x){mean(x)})
#ciP1=(medP + alpha50/2) - sqrt(alpha50)*sqrt(medP + alpha50/4); ciP2=(medP + alpha50/2) + sqrt(alpha50)*sqrt(medP + alpha50/4) # Poisson CI
#ciP195=(medP + alpha95/2) - sqrt(alpha95)*sqrt(medP + alpha95/4); ciP295=(medP + alpha95/2) + sqrt(alpha95)*sqrt(medP + alpha95/4) # Poisson CI
polygon(c(simtitreX[1,],rev(simtitreX[1,])),c(ciP195,rev(ciP295)),lty=0,col=rgb(0,0.3,1,0.1))
polygon(c(simtitreX[1,],rev(simtitreX[1,])),c(ciP1,rev(ciP2)),lty=0,col=rgb(0,0.3,1,0.2))
lines(simtitreX[1,],medP,pch=1,col='blue')
points(simtitreX[1,],medP,pch=19,cex=0.5,col='blue')
# Plot true titres - check select correct values
points(min(inf_years)-1+test.list[[ part_pick[ii0] ]][[ n.testMatch[pickyr] ]][4,],test.list[[ part_pick[ii0] ]][[ n.testMatch[pickyr] ]][2,],pch=1,col='red')
title(main=LETTERS[titleN],adj=0)
titleN=titleN+1
}  # end loop over participants
} # end loop over test years
dev.copy(pdf,paste("plot_simulations/titre_compare/FIGURE_titre_plot",loadseed,".pdf",sep=""),width=8,height=7)
dev.off()
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Plot simulated data
plot.sim.data<-function(){
loadseed="SIM"
load(paste("R_datasets/Simulated_data_",loadseed,"_1.RData",sep=""))
#load("R_datasets/Simulated_dataPost_1.RData")
#Compare model fits using posterior infection history (historytabPost) and parameters
picktest=c(2007:2012)
n.test=length(picktest)
simulate_data(test_years=picktest,historytabPost=historytabSim,
inf_years,
strain_years,
n_part=npartM,thetastar=thetaSim,p.inf=0.1) #theta.max
load("R_datasets/Simulated_dataPost_1.RData")
par(mfrow=c(2,5))
par(mar = c(5,5,1,1))
for(pickyr in 1:n.test){
for(ii0 in 1:n_part){
plot(8*historytabSim[ii0,],type="l",ylim=c(0,9),col='white')
#for(jj in 1:length(lenhis)){
#  lines(c(jj,jj),c(0,9*historytabSim[ii0,jj]),col='red')
#}
histSim1=historytabSim[ii0,]
histSim1[inf_years>picktest[pickyr]]=0 # don't show infections after test year
lenhis=rep(0,length(histSim1))
for(jj in 1:length(lenhis)){
lines(c(jj,jj),c(0,9*histSim1[jj]),col='blue')
}
lines(test.listSim[[ii0]][[pickyr]][4,],test.listSim[[ii0]][[pickyr]][2,],col=rgb(0.8,0.8,0.8),lwd=2) # Plot estimated infections
points(test.listSim[[ii0]][[pickyr]][4,],test.listSim[[ii0]][[pickyr]][2,],pch=19)
if(ii0 %% 10==0){
dev.copy(pdf,paste("plot_simulations/simPlot",ii0,"P_",pickyr,".pdf",sep=""),width=12,height=6)
dev.off()
}
}
}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Rewind history and run with flat incidence
run.titre.time<-function(loadseed=1,year_test=c(2007:2012),flu.type="H3",simDat=F,btstrap=5,n_partSim=2,simTest.year=c(1968:2010)){
if(simDat==F){
if(flutype=="H3"){load("R_datasets/HaNam_data.RData")}
if(flutype=="B"){load("R_datasets/Fluscape_data.RData")}
if(flutype=="H1"){load("R_datasets/HK_data.RData")}
loadseed=paste(loadseed,"_",flu.type,sep="")
}else{
load(paste("R_datasets/Simulated_data_",loadseed,"_1.RData",sep=""))
}
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,".RData",sep="")) # Note that this includes test.listPost
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
runs1=ceiling(0.2*runsPOST)
# Set up matrices to store -- need btstrap >1
strain_years=inf_years # look at strains from every year
n.strains=length(strain_years) # this loads from main_model.R
n.inf=length(inf_years)
hist.sample0=rep(c(1,rep(0,29)),100)[1:n.inf] # CURRENTLY JUST FOR ONE PARTICIPANT
simTest.year=sort(c(inf_years[hist.sample0==1],inf_years[hist.sample0==1]+1)) # infection year and one year after
n.test=length(simTest.year)
store.mcmc.test.data=array(NA, dim=c(btstrap,n_partSim,n.strains,n.test,2)) # Store expected titres for each test year
store.mcmc.hist.data=array(NA, dim=c(btstrap,n_partSim,n.inf,n.test)) # Store history for each test year
# - - - - - - - - - - - -
# Sample from MCMC runs to get stored matrices of expected titre and estimated infection years
for(sampk in 1:btstrap){
pickA=sample(c(runs1:runsPOST),1)
pickAhist=ceiling(pickA/20)+1 # check which history this specifies
hist.sample=rbind(hist.sample0,hist.sample0)
theta.max=as.data.frame(thetatab)[pickA,]
for(pickyr in 1:n.test){ # ITERATE OVER TIME HERE
# Note here that inf_years and strain_years are loads from main_model
#hist.sample0[ inf_years<simTest.year[pickyr] ] # only take years up to test year -- already included in simulation function!
simulate_data(simTest.year[pickyr],historytabPost=hist.sample,
inf_years,
strain_years,
n_partSim,thetastar=theta.max,p.inf=0.1,
#pmask=c("sigma2"), # For old fitted data, need to specify that sigma2 wasn't fitted
linD=F)
load("R_datasets/Simulated_dataPost_1.RData")
# Mask infections after test year
for(ii0 in 1){
sim.titre=test.listSim[[ii0]][[1]] # sort sample years - drawn from simulated data above
hist.sampleB=hist.sample;  hist.sampleB[,as.numeric(colnames(hist.sample))>test.yr[pickyr]]=0 # don't show infections after test year
store.mcmc.test.data[sampk,ii0,,pickyr,1]= min(inf_years)-1+sort(sim.titre["sample.index",]) # Sampled strain years
s.titre=sim.titre["titredat",order(sim.titre["sample.index",])]
store.mcmc.test.data[sampk,ii0,,pickyr,2]=s.titre # Sampled expected titre
#store.mcmc.test.data[sampk,ii0,,pickyr,2]=rpois(length(s.titre),lambda=s.titre) # Sampled expected titre - include Poisson noise
store.mcmc.hist.data[sampk,ii0,,pickyr]=hist.sampleB[ii0,] # Sampled history
}  # end loop over participants
} # end loop over test years
} # end bootstrap loop
# - - - - - - - - - - - -
# Plot development of titres
par(mfrow=c(1,1)); par(mar = c(5,5,1,1))
plot(inf_years,8*hist.sample[1,],type="l",ylim=c(0,9),col='white',xlab="year",ylab="titre")
for(pickyr in 1:n.test){
# Mask infections after test year
for(ii0 in 1){
simtitreX=store.mcmc.test.data[,ii0,,pickyr,1]
simtitreY=store.mcmc.test.data[,ii0,,pickyr,2]
hist.sample=store.mcmc.hist.data[,ii0,,pickyr] # for participant ii0 in year pickyr
# Sample from infection history
for(ksamp in 1:btstrap){
for(jj in 1:n.inf){
lines(min(inf_years)-1+c(jj,jj),c(-1,12*hist.sample[ksamp,jj]-1),col=rgb(0.8,0.8,0.8,0.01),lwd=2) # Plot estimated infections
}
}
# Calculate credible interval for expected titres
medP=apply(simtitreY,2,function(x){median(x)})
ciP1=apply(simtitreY,2,function(x){quantile(x,0.025)})
ciP2=apply(simtitreY,2,function(x){quantile(x,0.975)})
polygon(c(simtitreX[1,],rev(simtitreX[1,])),c(ciP1,rev(ciP2)),lty=0,col=rgb(0,0.3,1,0.2))
lines(simtitreX[1,],medP,pch=1,col='blue')
points(simtitreX[1,],medP,pch=19,cex=0.5,col='blue')
if(ii0 %% 10==0){
dev.copy(pdf,paste("plot_simulations/sim",ii0,"P_",pickyr,".pdf",sep=""),width=12,height=6)
dev.off()
}
}  # end loop over participants
} # end loop over test years
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Rewind history and run with flat incidence
plot.antibody.changes<-function(loadseed=1,year_test=c(2007:2012),flu.type="H3",simDat=F,btstrap=5,n_partSim=2,simTest.year=c(1968:2010)){
# btstrap=50 ; n_partSim=2 ; simTest.year=c(1968:2010)
load("R_datasets/HaNam_data.RData")
loadseed="1_H3" #paste(loadseed,"_",flu.type,sep="")
load(paste("posterior_sero_runs/outputR_f",paste(year_test,"_",collapse="",sep=""),"s",loadseed,".RData",sep="")) # Note that this includes test.listPost
lik.tot=rowSums(likelihoodtab)
runsPOST=length(lik.tot[lik.tot!=-Inf])
runs1=ceiling(0.2*runsPOST)
thetaT=as.data.frame(thetatab)[runs1:runsPOST,]
sampleX = 10
year_x = seq(0,3,0.01) ;   year_x2 = seq(0,3,0.1) ; cross_x = seq(0,30,0.1) ;  cross_x2 = seq(0,30,1)
Dmed = 3; Dlong = 10; Tmed = 0.5; Tlon = 3 # Define values for plots
# 1D plots
# Store bootstrap runs
storetitreS = NULL; storetitreM = NULL; storetitreL = NULL;
storetitreCrossS = NULL ; storetitreCrossM = NULL; storetitreCrossL = NULL
for(sampk in 1:btstrap){
# Sample from MCMC posterior to get trajectory
pickA=sample(c(runs1:runsPOST),1)
theta.max=as.data.frame(thetatab)[pickA,]
storetitreS = rbind(storetitreS, sapply( theta.max$mu + theta.max$muShort*exp(- year_x * theta.max$wane), function(x){min(8, x)}) )
#storetitreM = rbind(storetitreM, sapply( theta.max$mu*exp(-theta.max$sigma*Dmed) + theta.max$muShort*exp(- year_x * theta.max$wane)*exp(-theta.max$sigma2*Dmed), function(x){min(8, x)}) )
storetitreL = rbind(storetitreL, sapply( theta.max$mu*exp(-theta.max$sigma*Dlong) + theta.max$muShort*exp(- year_x * theta.max$wane)*exp(-theta.max$sigma2*Dlong), function(x){min(8, x)}) )
storetitreCrossS = rbind(storetitreCrossS, sapply( theta.max$mu*exp(-theta.max$sigma*abs(cross_x)) + theta.max$muShort*exp(-theta.max$sigma2*abs(cross_x)), function(x){min(8, x)}) )
#storetitreCrossM = rbind(storetitreCrossM, sapply( theta.max$mu*exp(-theta.max$sigma*abs(cross_x)) + theta.max$muShort*exp(-theta.max$sigma2*abs(cross_x))*exp(- Tmed * theta.max$wane), function(x){min(8, x)}) )
storetitreCrossL = rbind(storetitreCrossL, sapply( theta.max$mu*exp(-theta.max$sigma*abs(cross_x)) + theta.max$muShort*exp(-theta.max$sigma2*abs(cross_x))*exp(- Tlon * theta.max$wane), function(x){min(8, x)}) )
}
titreL = apply(storetitreL,2,function(x){c.nume(x)})
#titreM = apply(storetitreM,2,function(x){c.nume(x)})
titreS = apply(storetitreS,2,function(x){c.nume(x)})
titreCrossL = apply(storetitreCrossL,2,function(x){c.nume(x)})
#titreCrossM = apply(storetitreCrossM,2,function(x){c.nume(x)})
titreCrossS = apply(storetitreCrossS,2,function(x){c.nume(x)})
col1P=rgb(0,0,0.8) # rgb(0,0.5,0)
col1=rgb(0,0,0.8,0.005) # rgb(0,0.5,0,0.03)
col1a=rgb(0,0,0.8,0.1) # rgb(0,0.5,0,0.03)
col2P=rgb(0,0,1)
col2=rgb(0,0,1,0.2)
col3P=rgb(1,0,0.5)
col3=rgb(1,0,0.2,0.2)
pois.gen <- function(x,rep){rpois(rep,lambda = x)} # Function to generate random samples
# - - - - - - - - - - - - - - - - - - - - - -
# PLOT PARAMETERS FIGURE 3
# 1. Plot titre waning
par(mfrow=c(1,2)); par(mar = c(3,3,1,1))
par(mgp=c(1.8,0.6,0))
plot(year_x,titreS[1,],ylim=c(-0.1,8.5),type="l",ylab="log titre",xlab="years since infection",col=NULL,xaxs="i",yaxs="i")
polygon(c(year_x,rev(year_x)),c(titreS[2,],rev(titreS[3,])),col=col1a,lty=0)
#polygon(c(year_x,rev(year_x)),c(titreM[2,],rev(titreM[3,])),col=col2,lty=0)
#polygon(c(year_x,rev(year_x)),c(titreL[2,],rev(titreL[3,])),col=col3,lty=0)
for(ii in 1:length(year_x2)){
titreSsim = pois.gen(storetitreS[,(ii-1)*sampleX+1],btstrap) # Simulate from Poisson - sample fewer than previous
tstore=data.frame(table(titreSsim),stringsAsFactors = F)
t.alpha=tstore$Freq/btstrap
points(rep(year_x2[ii],length(tstore$titreSsim)),as.numeric(levels(tstore$titreSsim))[tstore$titreSsim],col=rgb(0,0,0.8,t.alpha),pch=19,cex=0.5)
}
lines(year_x,titreS[1,],col=col1P ,lwd = 2)
#lines(year_x,titreM[1,],col=col2P)
#lines(year_x,titreL[1,],col=col3P)
title(main=LETTERS[1],adj=0)
# 2. Plot cross reaction
par(mar = c(3,2,1,1))
plot(cross_x,titreCrossS[1,],ylim=c(-0.1,8.5),type="l",ylab="",xlab="antigenic distance",col=NULL,xaxs="i",yaxs="i")
polygon(c(cross_x,rev(cross_x)),c(titreCrossS[2,],rev(titreCrossS[3,])),col=col1a,lty=0)
#polygon(c(cross_x,rev(cross_x)),c(titreCrossM[2,],rev(titreCrossM[3,])),col=col2,lty=0)
polygon(c(cross_x,rev(cross_x)),c(titreCrossL[2,],rev(titreCrossL[3,])),col=col3,lty=0)
for(ii in 1:length(cross_x2)){
titreSsim = pois.gen(storetitreCrossS[,(ii-1)*sampleX+1],btstrap) # Simulate from Poisson - sample fewer than previous
tstore=data.frame(table(titreSsim),stringsAsFactors = F) ; t.alpha=tstore$Freq/btstrap
points(rep(cross_x2[ii],length(tstore$titreSsim)),as.numeric(levels(tstore$titreSsim))[tstore$titreSsim],col=rgb(0,0,0.8,t.alpha),pch=19,cex=0.5)
titreSsim = pois.gen(storetitreCrossL[,(ii-1)*sampleX+1],btstrap)
tstore=data.frame(table(titreSsim),stringsAsFactors = F) ; t.alpha=tstore$Freq/btstrap
points(rep(cross_x2[ii],length(tstore$titreSsim)),as.numeric(levels(tstore$titreSsim))[tstore$titreSsim],col=rgb(1,0,0.5,t.alpha),pch=19,cex=0.5)
}
lines(cross_x,titreCrossS[1,],col=col1P,lwd = 2)
#lines(cross_x,titreCrossM[1,],col=col2P)
lines(cross_x,titreCrossL[1,],col=col3P)
title(main=LETTERS[2],adj=0)
dev.copy(pdf,paste("plot_simulations/parameters",loadseed,".pdf",sep=""),width=7,height=4)
dev.off()
}
plot.posterior.titres(loadseed=1,flu.type="H1",simDat=F,year_test=c(2009:2011),btstrap=2)
data.infer(year_test=dy1,mcmc.iterations=1e5,loadseed=kk,flutype=flutype0,fix.param=c("disp_k","muShort"),fit.spline=NULL) #,"map.fit"
plot.posteriors(year_test=dy1,loadseed=kk,flutype=flutype0,f.lim=T,plotmap = F)
