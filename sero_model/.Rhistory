likelihood.titre<-function(expect,titredat,theta){
largett=(titredat>=8)  # Identify censored titres in data (>=8)
# Calculate P(observe j | true titre is k) - no error
#p_jk = sum(dpois(as.numeric(titredat[!largett]), expect[!largett], log = TRUE))+ sum(ppois(8, lambda=expect[largett], lower=FALSE,log=TRUE))
# Include uniform error i.e. L(j)= sum_k P(true titre is k) x P(observe j | true titre is k) - derivation is in PLOS Biol supplement
p_jk = sum( log(dpois(as.numeric(titredat[!largett]), expect[!largett], log = FALSE) *(1-theta[["error"]])+theta[["error"]]/9 ) )
+ sum(log(ppois(8, lambda=expect[largett], lower=FALSE,log=FALSE)*(1-theta[["error"]])+theta[["error"]]/9  ))
# Include negative binomial function
#p_jk = sum( log(dnbinom(as.numeric(titredat[!largett]), mu=expect[!largett], size=theta[["disp_k"]], log = FALSE) *(1-theta[["error"]])+theta[["error"]]/9 ) )
#        + sum(log(pnbinom(8, mu=expect[largett], size=theta[["disp_k"]], lower.tail=FALSE,log=FALSE)*(1-theta[["error"]])+theta[["error"]]/9  ))
p_jk
}
# - - - - - - - - - - - - - - - -
# Calculate likelihood for given participant and test year
estimatelik<-function(ii,jj,historyii,dmatrix,dmatrix2,theta_star,test.list,testyearI){ # ii=participant | jj=test year
test.II=test.list[[ii]]
test.jj=test.II[[jj]]
# Check test data available
if(length(test.jj[,1])==1){0}else{
# Set up test strains
test.part=as.numeric(test.jj[4,]) # index of sample strains data available for
titredat=test.jj[2,] # Define titre data
d.ij=dmatrix[test.part,] # Define cross-immunity matrix 1 for sample strain
d_vector=melt(t(d.ij))$value #melt is by column
d.ij2=dmatrix2[test.part,] # Define cross-immunity matrix 2 for sample strain
d_vector2=melt(t(d.ij2))$value #melt is by column
expect=func1(historyii,titredat,d_vector,d_vector2,theta_star,testyearI) # Output expectation
#print(likelihood.titre(expect,titredat,theta_star))
likelihood.titre(expect,titredat,theta_star)
}
}
# - - - - - - - - - - - - - - - -
# Simulation infection history data
simulate_data<-function(test_years,
historytabPost=NULL, # This imposes a particular history
inf_years,strain_years,n_part=20,thetastar=theta0,p.inf=0.2,seedi=1,
roundv=F, # round expected titres to nearest integer?
linD=F, # use linear cross-reaction function?
antigenic.map.in=NULL,pmask=NULL){ # ii=participant | jj=test year
# test_years=test.yr[pickyr]; historytabPost=hist.sample; thetastar=theta.max; p.inf=0.1 # DEBUG
#pmask=c("sigma2"), # For old fitted data, need to specify that sigma2 wasn't fitted
linD=F
# Variables needed: test_years,inf_years,strain_years,n_part
#strain_years=seq(1968,2010,4)
# Make adjustments depending on what is fitted and not
if(sum(pmask=="muShort")>0){thetastar[["muShort"]]=1e-10} # Set short term boosting ~ 0 if waning not fitted
if(sum(pmask=="map.fit")>0){ thetastar[["sigma"]]=1} # Set cross-reactivity = 1 and don't fit if antigenic map also fitted (to avoid overparameterisation)
if(sum(pmask=="sigma2")>0){ thetastar[["sigma2"]]=thetastar[["sigma"]] } # Fix equal if sigma same for both
# Set year of birth
age.yr=sample(1:80,n_part,replace = TRUE)
test.n=length(test_years)
inf.n=length(inf_years)
nstrains=length(strain_years)
sample.index=strain_years-min(inf_years)+1
theta.sim.out=thetastar
historytabSim2=historytabPost
# Check inputs are correct
if(sum(max(test_years)==inf_years)==0){
print("need infection years >= test years")
return
}
if(is.null(antigenic.map.in)){antigenic.map.in=inf_years} # If no specified antigenic map, use linear function by year
dmatrix=outputdmatrix.fromcoord(thetastar[["sigma"]],inf_years,antigenic.map.in)
dmatrix2=outputdmatrix.fromcoord(thetastar[["sigma2"]],inf_years,antigenic.map.in)
#Set per year incidence, to create correlation between participant infection histories
log.sd=1
if(length(p.inf)==1){
attack.yr=rlnorm(inf.n,meanlog=log(p.inf)-log.sd^2/2,sdlog=log.sd)
}else{
attack.yr=p.inf
}
# Simulate random infection history for each infection year
if(is.null(historytabPost)){
historytabSim=matrix(0,ncol=inf.n,nrow=n_part)
for(ii in 1:inf.n){
#hist0=(runif(inf.n)<attack.yr)+0
#alive=((max(test_years)-age.yr[ii])<=inf_years) - ignore age structure for the moment
historytabSim[sample(n_part,round(n_part*attack.yr[ii])),ii]=1
}
}else{
historytabSim=historytabPost
}
# Simulate titres for each participant
test.list=list()
for(ii in 1:n_part){
subjectn=ii
i.list=list()
historyii=historytabSim[ii,]
for(jj in 1:test.n){
d.ij=dmatrix[sample.index,] # Define cross-immunity matrix for sample strain
d_vector=melt(t(d.ij))$value
d.ij2=dmatrix2[sample.index,] # Define cross-immunity matrix for sample strain
d_vector2=melt(t(d.ij2))$value
testyr=test_years[jj]
testyearI=c(1:inf.n)[inf_years==testyr]
expect=func1(historyii,sample.index,d_vector,d_vector2, thetastar,testyearI) # Output expectation
#DEBUG
thetastar[["wane"]]=1
func1(historyii,titredat=1,d_vector,d_vector2, thetastar,testyear_index=1) # Output expectation
# END DEBUG
#titredat=sapply(expect,function(x){rpois(1,x)}) # Generate titre
if(roundv==T){titredat=round(expect)}else{titredat=expect}
titredat=sapply(titredat,function(x){min(x,8)})
i.list[[jj]]=rbind(test.year=rep(testyr,nstrains),
titredat,
strain_years,
sample.index
)
}
#i.list[[1]][2,]
test.list[[ii]]=i.list
}
test.listSim=test.list
# Export data
#browser()
if(is.null(historytabPost)){
save(test_years,inf_years,strain_years,n_part,test.listSim,theta.sim.out, age.yr,antigenic.map.in,historytabSim,file=paste("R_datasets/Simulated_data_",seedi,".RData",sep=""))
}else{
save(test_years,inf_years,strain_years,n_part,test.listSim,theta.sim.out, age.yr,antigenic.map.in,historytabSim2,file=paste("R_datasets/Simulated_dataPost_",seedi,".RData",sep=""))
}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Resample infection history - included ageA table in case needed later
SampleHistory<-function(historyA,pick,inf.n,ageA,inf_years){
infvector=c(1:inf.n)
infvector2=rev(infvector)
for(ii in pick){
#ls_pick=foreach(ii=(1:length(pick))) %dopar% {  # Parallel loop - slower to farm out
rand1=runif(1)
x=historyA[ii,]
# Remove infection
if(rand1<1/3){
infectID=infvector[(as.numeric(x)>0)]
if(length(infectID)>0){
x[sample(c(infectID,infectID),1)]=0
}
}
# Add new infection
if(rand1>1/3 & rand1<2/3){
ninfecID=infvector[(as.numeric(x)==0)]
if(length(ninfecID)>0){
x[sample(c(ninfecID,ninfecID),1)]=1
}
}
# Move infection
if(rand1>2/3){
infectID=infvector[(as.numeric(x)>0)]
ninfecID=infvector[(as.numeric(x)==0)]
if(length(infectID)>0 & length(ninfecID)>0){
x[sample(c(infectID,infectID),1)]=0
x[sample(c(ninfecID,ninfecID),1)]=1
}
}
# Add prior on birth year - exponentially less likely to update if infections outside
#if(inf.n>ageA[ii]){
#  a1=0.01*exp(1)*exp(-sum(x[1:(inf.n-ageA[ii])])) # EDIT infvector2 tweak this parameter to penalise more/less
#  if( a1 > runif(1) ){
#    historyA[ii,]=x
#  }
#}
historyA[ii,]=x
} # end loop over individuals
historyA
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Resample age - add 1, 0, -1 with equal probability -- NOTE THIS IS NOT CURRENTLY ACTIVE
SampleAge<-function(pick,ageA){
b1=sapply(ageA[pick],function(x){x+sample(c(-1:1),1)})
ageA[pick]=b1
ageA
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Resample antigenic location
SampleAntigenicMap<-function(anti.map.star,epsilon.map,inf_years){
Sigma0=(diag(1+0*inf_years))*epsilon.map
#Sigma0[1,1]=0 # Anchor initial point
if(length(anti.map.star)==length(inf_years)){
sort(as.numeric(mvrnorm(1,anti.map.star, Sigma=Sigma0)))
}else{
apply(anti.map.star,2, function(x){as.numeric(mvrnorm(1,x, Sigma=Sigma0))})
}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Convert infection history to binary -- NOTE THIS IS NOT CURRENTLY ACTIVE
convert_binary <- function(x){sum(2^(which(rev(unlist(strsplit(as.character(x), "")) == 1))-1))}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ComputeProbability<-function(marg_likelihood,marg_likelihood_star){
# Flat priors on theta => symmetric update probability
calc.lik = exp(marg_likelihood_star-marg_likelihood)
min(1, calc.lik)
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SampleTheta<-function(theta_initial,m,covartheta,covarbasic,nparam){
# sample from multivariate normal distribution - no adaptive sampling
theta_star = as.numeric(exp(mvrnorm(1,log(theta_initial), Sigma=covarbasic)))
# sample from multivariate normal distribution - include adaptive samples (Roberts & Rosenthal, 2009)
#theta_star = 0.05*as.numeric(exp(mvrnorm(1,log(theta_initial), Sigma=(2.38^2/nparam)*covarbasic))) +
#              0.95*as.numeric(exp(mvrnorm(1,log(theta_initial), Sigma=(2.38^2/nparam)*covartheta)))
names(theta_star)=names(theta_initial)
# reflective boundary condition for max boost=10
mu1=min(20-theta_star[["mu"]],theta_star[["mu"]])
theta_star[["mu"]]=ifelse(mu1<0,theta_initial[["mu"]],mu1)
#mu2=min(20-theta_star[["muShort"]],theta_star[["muShort"]])
#theta_star[["muShort"]]=ifelse(mu2<0,theta_initial[["muShort"]],mu2)
# reflective boundary condition for error function
error2=min(2-theta_star[["error"]],theta_star[["error"]])
theta_star[["error"]]=ifelse(error2<0,theta_initial[["error"]],error2)
#print(rbind(theta_initial,theta_star1,theta_star2))
return(thetaS=theta_star)
}
# DEBUG CHECK
#theta01=theta
#while(max(theta01)>0){
#  theta01=SampleTheta(theta01,1,covartheta=cov_matrix_basic,covarbasic=10*cov_matrix_basic,length(theta))
#
#}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Metropolis-Hastings algorithm
run_mcmc<-function(
test.yr,
test_years,
inf_years,
strain_years,
n_part,
test.list,
theta,
runs,
varpart_prob,
hist.true=NULL,
switch1=2,
seedi=1,
pmask=NULL,
linD=F, # toggles linear/exponential cross-reactivity function
antigenic.map.in=NULL, # define specific map structure (or initial structure if fitting)
am.spline=NULL # fit antigenic map along defined spline function
){
# DEBUG set params <<<
# hist.true=NULL; test.yr=c(2007); runs=200; switch1=10; varpart_prob=0.05 ;   seedi=1; linD=F; pmask=NULL
if(is.null(antigenic.map.in)){antigenic.map.in=inf_years} # if no input map, assume 1D
test.n=length(test_years); inf.n=length(inf_years); nstrains=length(strain_years)
sample.index=strain_years-min(inf_years)+1
test.listPost=test.list
historyii=rbinom(inf.n, 1, 0.1) # dummy infection history
# Index variables
jj_year=match(test.yr,test_years); testyear_index=match(test.yr,inf_years)
sample.n=length(jj_year)
# Specific MCMC parameters
#browser()
# Make adjustments depending on what is fitted and not
if(sum(pmask=="muShort")>0){theta[["muShort"]]=1e-10} # Set short term boosting ~ 0 if waning not fitted
#if(sum(pmask=="map.fit")>0){ theta[["sigma"]]=1; pmask=c(pmask,"sigma","sigma2")} # Set cross-reactivity = 1 and don't fit if antigenic map also fitted (to avoid overparameterisation)
if(sum(pmask=="sigma2")>0){ theta[["sigma2"]]=theta[["sigma"]] } # Fix equal if sigma same for both
# Preallocate memory
nparam=length(theta); npcov=rep(1,nparam); npcov[match(pmask,names(theta))]=0 # mask specified parameters
cov_matrix_theta0 = diag(npcov)
cov_matrix_thetaA=cov_matrix_theta0
thetatab=matrix(NA,nrow=(runs+1),ncol=length(theta)); colnames(thetatab)=names(theta)
thetatab[1,]=theta
historytab=matrix(NA,nrow=n_part,ncol=inf.n)
historytabCollect=historytab
age.tab=matrix(NA,nrow=n_part,ncol=1)
map.tab=antigenic.map.in
map.tabCollect=list()
# Pick plausible initial conditions -- using all test years
if(is.null(hist.true)){
for(ii in 1:n_part){
histIC=NULL
for(kk in 1:length(jj_year)){
histIC=rbind(histIC,setuphistIC(ii,jj_year[kk],inf.n,test.list,testyear_index,inf_years))
}
historytab[ii,]=as.numeric(colSums(histIC)>0)
}
} else { historytab=hist.true }
colnames(historytab)=as.character(inf_years)
# Plausible intial ages - based on earliest strain in history
#age.tab=sapply(
#  apply(historytab,1,function(x){min(c(inf.n:1)[x==1])}),
#  function(y){ sample(y:80, 1, replace=T) })
# Preallocate matrices
likelihoodtab=matrix(-Inf,nrow=(runs+1),ncol=n_part)
accepttabT=NULL
accepttabH=NULL
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run MCMC
for (m in 1:runs){
# Adaptive covariance matrix
if(m==1){
epsilon0=0.01
cov_matrix_theta=epsilon0*cov_matrix_thetaA
cov_matrix_basic=epsilon0*cov_matrix_theta0
varpart_prob0=varpart_prob
}else{
epsilon0=max(0.00001,min(1,exp(log(epsilon0)+(accept_rateT-0.234)*0.999^m)))
cov_matrix_theta=epsilon0*cov_matrix_thetaA
cov_matrix_basic=epsilon0*cov_matrix_theta0
varpart_prob0=max(0.01,min(0.25,exp(log(varpart_prob0)+(accept_rateH-0.234)*0.999^m))) # resample max of 25%, min of 1%
}
# - - - - - - - - - - - - - - - -
# Resample parameters
if(m %% switch1==0 | m==1){ # m==1 condition as have to calculate all liks on first step
theta_star = SampleTheta(thetatab[m,], m,cov_matrix_theta,cov_matrix_basic,nparam=sum(cov_matrix_theta0)) #resample theta
if(sum(pmask=="sigma2")>0){ theta_star[["sigma2"]]=theta_star[["sigma"]] } # Fix equal if sigma same for both
if(sum(pmask=="map.fit")>0){ # check whether to fit antigenic map
map_star=SampleAntigenicMap(anti.map.star=map.tab,epsilon.map=epsilon0,inf_years) # resample antigenic map
}else{
map_star=map.tab
}
SampleAntigenicMap(anti.map.star=inf_years,epsilon.map=0.01,inf_years) # sample antigenic map
#age_star = age.tab
history_star = historytab
pickA=c(1:n_part)
}else{
pickA=NULL
pickA=sample(n_part, ceiling(varpart_prob0*n_part)) # check that not length zero (i.e. at least one person sampled)
#age_star = age.tab #SampleAge(pickA,age.tab) #resample age (not for now)
history_star = SampleHistory(historytab,pickA,inf.n,age_star,inf_years) #resample history
theta_star =thetatab[m,]
}
#print(am.spline) # DEBUG
dmatrix= outputdmatrix.fromcoord(theta_star[["sigma"]] ,inf_years,anti.map.in=map_star,spl.fn=am.spline) # Arrange antigenic map into cross-reaction matrix
dmatrix2=outputdmatrix.fromcoord(theta_star[["sigma2"]],inf_years,anti.map.in=map_star,spl.fn=am.spline) # Arrange antigenic map into cross-reaction matrix
# - - - - - - - - - - - - - - - -
# LIKELIHOOD function - Only calculate for updated history
lik_val=likelihoodtab[m,]
for(ii in pickA){
# Set history to zero after test date
lik.ii=rep(NA,sample.n)
for(kk in 1:sample.n){
#For DEBUG: set params <<<  ii=1;kk=2;historyii=as.numeric(history_star[ii,])
lik.ii[kk]=estimatelik(ii,jj_year[kk],as.numeric(history_star[ii,]),dmatrix,dmatrix2,theta_star,test.list,testyear_index[kk])
#if(lik.ii[kk]==-Inf){print(c(ii,kk))  } For DEBUG
}
lik_val[ii]=sum(lik.ii)
#if(is.na(lik_val[ii])){ lik_val[ii]=-Inf} For DEBUG
}
# - - - - - - - - - - - - - - - -
# Metropolis Hastings step
output_prob = ComputeProbability(sum(likelihoodtab[m,]),sum(lik_val))
#if(is.na(output_prob)){print(c(m,sum(likelihoodtab[m,]),sum(lik_val),theta_star))} # Print likelihood (For DEBUG)}
if(is.na(output_prob) & m==1){stop('check initial parameter values')}
if(runif(1) < output_prob){
thetatab[m+1,] = theta_star
if(m %% switch1!=0){historytab = history_star} # Only change if resampled
if(m %% switch1==0){map.tab = map_star} # Only change if resampled
#if(m %% switch1==0){age.tab = age_star} # Only change if resampled - not currently active
likelihoodtab[m+1,] = lik_val
if(m %% switch1==0){accepttabT=c(accepttabT,1)}
if(m %% switch1!=0){accepttabH=c(accepttabH,1)}
}else{
thetatab[m+1,] = thetatab[m,]
likelihoodtab[m+1,] = likelihoodtab[m,]
if(m %% switch1==0){accepttabT=c(accepttabT,0)}
if(m %% switch1!=0){accepttabH=c(accepttabH,0)}
}
if(m<max(100)){
accept_rateT=0.234 # target acceptance rate for theta
accept_rateH=0.234 # target acceptance rate for infection history
}else{
accept_rateT=sum(accepttabT)/length(accepttabT)
accept_rateH=sum(accepttabH)/length(accepttabH)
cov_matrix_thetaA=cov(thetatab[1:m,]) # Include adaptive covariance matrix for MCMC
}
if(m %% min(runs,20) ==0){
historytabCollect=rbind(historytabCollect,historytab)
map.tabCollect[[round(m/20)]]=map.tab
}
if(m %% min(runs,1000) ==0){
print(c(m,accept_rateT,varpart_prob0,round(sum(likelihoodtab[m,]))))
save(likelihoodtab,thetatab,inf_years,n_part,test.listPost,historytab,historytabCollect,map.tabCollect,age.tab,test.yr,switch1,file=paste("posterior_sero_runs/outputR_f",paste(test.yr,"_",collapse="",sep=""),"s",seedi,".RData",sep=""))
}
} #End runs loop
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Inference using cross-sectional vs longitudinal data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
data.infer <- function(year_test,mcmc.iterations=1e3,loadseed=1,flutype="H3",fix.param=NULL , fit.spline=NULL) {
# INFERENCE MODEL
# Run MCMC for specific data set
if(flutype=="H3"){load("R_datasets/HaNam_data.RData")}
#am.spl<-load.flu.map.data() # define spline from antigenic map data
if(flutype=="B"){load("R_datasets/Fluscape_data.RData")}
if(flutype=="H1"){load("R_datasets/HK_data.RData")}
# Plot simulation data vs history
#source("simulation_plots.R")
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,wane=NA,sigma=NA,muShort=NA,error=NA,disp_k=NA,sigma2=NA)
theta0[["mu"]]=2 + if(sum(fix.param=="wane")==0){1*runif(1,c(-1,1))}else{0} # basic boosting
theta0[["tau1"]]=0.05 # back-boost
theta0[["tau2"]]=0.1 # suppression via AGS
theta0[["wane"]]=-log(0.5)/0.5 + if(sum(fix.param=="wane")==0){runif(1,c(-1,1))}else{0} # short term waning - half life of /X years -- add noise to IC if fitting
theta0[["sigma"]]=0.3 + if(sum(fix.param=="wane")==0){0.1*runif(1,c(-1,1))}else{0} # cross-reaction
theta0[["sigma2"]]=0.1 + if(sum(fix.param=="wane")==0){0.1*runif(1,c(-1,1))}else{0} # short-term cross-reaction
theta0[["muShort"]]=8 + if(sum(fix.param=="wane")==0){4*runif(1,c(-1,1))}else{0} # short term boosting
theta0[["error"]]=1e-5 # measurement error
theta0[["disp_k"]]=0.01 # dispersion parameter - NOT CURRENTLY USED
theta=theta0
vp1=0.02 #probability individual infection history resampled - this is adaptive in model
define.year=year_test # years to include in inference
# browser()
# RUN MCMC
# Note: NEED TO RE-INITIALISE DATAFRAME IF REPEAT RUN (i.e. reload dataset above)
run_mcmc(
test.yr=define.year,
test_years,
inf_years,
strain_years,
n_part,
test.list,
theta=theta0,
runs=mcmc.iterations, # number of MCMC runs
varpart_prob=vp1,
hist.true=NULL,
switch1=10, # ratio of infection history resamples to theta resamples. This is fixed
pmask=fix.param, #c("disp_k"), #c("wane"), #,"muShort"), # specify parameters to fix
seedi=paste(loadseed,"_",flutype,sep=""), # record output
antigenic.map.in=inf_years, # define specific map structure (or initial structure if fitting)
am.spline=fit.spline, # decide whether to fit antigenic map along "am.spl" spline function
linD=F)
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Define simulation model
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
simulation.infer <- function(seed_i,mcmc.iterations=1e3) {
loadseed=paste("SIM_",seed_i,sep="")
load("R_datasets/HaNam_data.RData")
# - - - - - - - - - - - - - - - - - - - - - - - - - -
# SIMULATION MODEL
# Generate simulated data
#tau1=back-boost  / tau2=suppress / disp_k=dispersion (deprecated)
#sigma1=long-term cross-reactivity / sigma 2=short-term CR
thetaSim = c(mu=3,tau1=0.02,tau2=0.1,wane=1,sigma=0.3,muShort=5,error=0.05,disp_k=1,sigma2=0.1)
npartM=70
# Generate 2D map
define.year=c(2007:2012) # test years
inf_years.in=seq(1968,2012,1)
sim.map.in = generate.antigenic.map(inf_years.in)
attack.yr=read.csv("datasets/sim_attack.csv")[,1]
#attack.yr=rlnorm(inf_years.in,meanlog=log(0.15)-1^2/2,sdlog=0.5)
#write.csv(attack.yr,"datasets/sim_attack.csv")
simulate_data(test_years=define.year, # this needs to be vector
inf_years=inf_years.in,strain_years=strain_years,n_part=npartM, #leave strain years blank to use HaNam strains
roundv=T, # Generate integer titre data
thetastar=thetaSim,
#antigenic.map.in = sim.map.in,
#pmask=c("wane","sigma2"), # Specify what is included
p.inf=attack.yr,seedi=loadseed)
# - - - - - - - - - - - - - - - - - - - - - - - - - - -
# INFERENCE MODEL
# Run MCMC for simulated data set
load(paste("R_datasets/Simulated_data_",loadseed,".RData",sep="")) # Load simulation data for inference step that follows
# Set initial theta
theta0=c(mu=NA,tau1=NA,tau2=NA,wane=NA,sigma=NA,muShort=NA,error=NA,disp_k=1,sigma2=0.1)
theta0[["mu"]]=2 # basic boosting
theta0[["tau1"]]=0.1 # back-boost
theta0[["tau2"]]=0.1 # suppression via AGS
theta0[["wane"]]=1  # -log(0.5)/1 # short term waning - half life of /X years
theta0[["sigma"]]=0.3 # long-term cross-reaction
theta0[["sigma2"]]=0.1 # short-term cross-reaction
theta0[["muShort"]]=3 # short term boosting
theta0[["error"]]=0.1 # measurement error
theta0[["disp_k"]]=0.1 # overdispersion (deprecated)
theta=theta0
vp1=0.02 #probability individual infection history resampled - this is adaptive in model
# browser()
sim.map.in0 = 0.3*(cbind(inf_years,inf_years)-min(inf_years)) #generate.antigenic.map(inf_years.in) # Define uniform initial map to fit
# RUN MCMC
# Note: NEED TO RE-INITIALISE DATAFRAME IF REPEAT RUN (i.e. reload dataset above)
run_mcmc(
test.yr=define.year,
test_years,
inf_years,
strain_years,
n_part,
test.list=test.listSim, # use simulated data as input
theta=theta0,
runs=mcmc.iterations, # number of MCMC runs
varpart_prob=vp1,
hist.true=NULL,
switch1=10, # ratio of infection history resamples to theta resamples. This is fixed
pmask=c("disp_k"), # ,"map.fit" specify parameters to fix
seedi=loadseed,
#antigenic.map.in= sim.map.in0, # Define random initial map to fit
linD=F)
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run code on network [SR code]
fn.network<-function(){
system.time(
for(ii in 1:1){  # Use multiple seeds for simulation code
fnSeedLoop(ii)
} # End loop over seeds
)
# Do some of these over the network
library("didewin")
didewin::didewin_config_global(credentials="~/.smbcredentials",
home="~/dide/home",
temp="~/dide/tmp")
make_trees <- function(n, nspp) {
lapply(seq_len(n), function(...) ape::rtree(nspp))
}
}
source("sero_functions.R")
source("posterior_analysis_flu.R")
source("sero_funcs_steven.r") # Load Flu B format
# Fits to spline if am.spl is defined [** AK: need to tidy this up **]
data.infer(year_test=dy1,mcmc.iterations=1e3,loadseed=kk,flutype=flutype0,fix.param=c("disp_k","error"),fit.spline=NULL) #,"map.fit"
plot.posteriors(year_test=dy1,loadseed=kk,flu.type=flutype0,f.lim=T,plotmap = F)
plot.posterior.titres(loadseed=1,flu.type="H1",simDat=F,year_test=c(2009:2011),btstrap=2)
data.infer(year_test=dy1,mcmc.iterations=1e4,loadseed=kk,flutype=flutype0,fix.param=c("disp_k","error"),fit.spline=NULL) #,"map.fit"
data.infer(year_test=dy1,mcmc.iterations=1e4,loadseed=kk,flutype=flutype0,fix.param=c("disp_k","error"),fit.spline=NULL) #,"map.fit"
data.infer(year_test=dy1,mcmc.iterations=1e4,loadseed=kk,flutype=flutype0,fix.param=c("disp_k","error","muShort"),fit.spline=NULL) #,"map.fit"
plot.posteriors(year_test=dy1,loadseed=kk,flu.type=flutype0,f.lim=T,plotmap = F)
